%%%%%% Static Data Flips %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Bitflip Attacks on ELF Files}\label{sec:elfattack}

In this chapter, we discuss our approach to automate the finding of bitflips in
ELF files to gain useable execution path changes. This is an idea which
Gruss~\etal~\cite{flipinthewall} already have realised by disassembling binaries
and manually looking for suitable flips. We start by describing the impact of a
single bitflip on the execution path. Then, we look at our work and the
framework we created to find bitflips in binaries to change their behaviour to a
pre-defined state. We go on with a general overview of the framework design and
continue with discussing the details on how we find bits to check, how the
definition for searching works, how we test the bitflips, and how results are
captured and verified. In the end, we discuss how these flips can be triggered
by using Rowhammer.

\section{Changing the Execution Path with a Single Bitflip}

Our task is to find a bit in an ELF file which we can flip to change the
behaviour in a way that it benefits us. As an example, see the code in
listing~\ref{lst:csimbranch}. We want to change the binary in a
way that it will print \texttt{success.} instead of \texttt{fail.} by just
toggling a single bit in the binary executing this code. We look at the
disassembly of the code in listing~\ref{lst:disasmsimplebranch}. From this, we
point out that we can start with changing the \texttt{1} to a \texttt{0} at
the \texttt{mov} instruction on address \texttt{0x0642}. Besides that, also the
opcode of \texttt{jnz}, namely \texttt{0x75 (1110101)}, can be changed into a
\texttt{jz}, as this is \texttt{0x74 (1110100)}, at address \texttt{0x064d}. For
compiling we used \texttt{gcc (Ubuntu 7.3.0-16ubuntu3) 7.3.0}~\cite{gccubuntu},
for disassembling \texttt{radare2 2.3.0-git 17214}~\cite{radare2web} was used.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Simple branching code to show an example for a
single bitflip to change the execution path.},
                   label={lst:csimbranch}]
#include <stdio.h>
int main(void)
{
  int x = 0;
  if(x == 1)
    printf("success.\n");
  else
    printf("fail.\n");
  return 0;
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=nasm,
                   caption={Disassemby of the main function created by the
code in listing~\ref{lst:csimbranch}. Shows machine code at given address
inside the ELF file, starting at \texttt{0x063a}.},
                   label={lst:disasmsimplebranch}]
0x063a  push rbp
0x063b  mov rbp, rsp
0x063e  sub rsp, 0x10
0x0642  mov dword [local_4h], 0
0x0649  cmp dword [local_4h], 1  ; [0x1:4]=0x2464c45
0x064d  jnz 0x65d
0x064f  lea rdi, str.success.    ; 0x6f4 ; "success."
0x0656  call sym.imp.puts        ; int puts(const char *s)
0x065b  jmp 0x669
0x065d  lea rdi, str.fail.       ; 0x6fd ; "fail."
0x0664  call sym.imp.puts        ; int puts(const char *s)
0x0669  mov eax, 0
0x066e  leave
0x066f  ret
\end{lstlisting}
\end{minipage}

We flip each bit of the instruction opcode \texttt{jnz} to line out what other
outcomes are possible with just a single flip. We apply all possible eight
flips and check the resulting output of the binary. Table~\ref{tab:jnzflips}
shows the flips and results. We can see that in three cases the program would
print \texttt{success.}, in one case the output would not change and in four
cases the program would crash for various reasons.

\begin{table}[]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
Opcode & Hex Value & Describtion                                           &
Output              \\ \hline
JZ     & 0x74      & Jump short if zero/equal                              &
success.            \\ \hline
JNBE   & 0x77      & Jump short if not below or equal/above                &
success.            \\ \hline
JNO    & 0x71      & Jump short if not overflow                            &
fail.               \\ \hline
JNL    & 0x7D      & Jump short if less or equal/not greater               &
success.            \\ \hline
GS     & 0x65      & GS segment override prefix                            &
Illegal instruction \\ \hline
PUSH   & 0x55      & ($50+r$) Push onto the Stack &
Illegal instruction \\ \hline
XOR    & 0x35      & Logical Exclusive OR                                  &
Segmentation fault  \\ \hline
CMC    & 0xF5      & Complement Carry Flag                                 &
Illegal instruction \\ \hline
\end{tabular}
\caption{Possible opcodes resulting from changing a single bit in
\texttt{JNZ}~\texttt{0x75} and the output when applied in the assembly showed in
listing~\ref{lst:disasmsimplebranch}.}
\label{tab:jnzflips}
\end{table}

From this, we gain the knowledge that at least three bitflips to the opcode give
us our desired behaviour. Additionally, we can add the bitflip to the $1$, which
makes it four. These flips we can find manually quite fast. Now, the question
arises how do we automate this searching process?

\section{Automating the Finding of Feasible Bitflips}

Testing all possible bitflips inside the binary and report each output would be
a way to gain a list of all flips which would result in the printing of
\texttt{success.}. The binary resulting from the compilation of the small
branching code from listing~\ref{lst:csimbranch} has a size of $8288$ bytes,
which means there are $66304$ flips to test. With an execution time of
approximately $0,003$ seconds per run, this means that it would take close to
$200$ seconds to test all bits inside the binary. For our automation, we want
to require way less time than that as we target larger binaries.

\subsection{Design of the Testing Framework}

We have implemented a framework to search bits to flip in binaries.
Figure~\ref{fig:frameworkdesign} shows a diagram describing the
framework\textquotesingle s design. We split it into multiple parts:

\begin{enumerate}
\begin{samepage}
  \item Accessed memory areas are logged from all the ELF files the program
uses.
  \item Pre-defined filters are applied to the reported memory areas.
  \item ELF files for each of the bit flips are generated.
  \item Each ELF file gets executed, and the behaviour is checked against a
pre-defined success state
\end{samepage}
\end{enumerate}

\begin{figure}
  \centering
  \begin{tikzpicture}
  % Nodes of the framework
  \node (start) [root] {Start};
  \node (conf) [function, right of=start, xshift=2cm] {Load config};
  \node (instr) [function, right of=conf, align=center, xshift=2cm]
                {Instrument \\ binary};
  \node (filter) [function, right of=instr, align=center, xshift=2cm]
                 {Filter \\ memory areas};
  \node (gen) [function, below of=filter, align=center, yshift=-1cm]
              {Generate \\ flipped binaries};
  \node (test) [function, below of=gen, align=center, yshift=-1cm]
               {Test \\ generated files};
  \node (report) [function, below of=test, align=center, yshift=-1cm]
                 {Log results};
  \node (clean) [function, right of=report, align=center, xshift=2cm]
                {Delete \\ generated files};
  \node (dec) [decision, below of=report, align=center, yshift=-1cm]
              {Finished?};
  \node (propclean) [function, left of=dec, align=center, xshift=-2cm]
                    {Cleanup \\ Testing \\ Environment};
  \node (printres) [function, left of=propclean, align=center, xshift=-2cm]
                   {Print Results};
  \node (finish) [finish, left of=printres, xshift=-2cm] {Done};
  % Connections
  \draw [arrow] (start) -- (conf);
  \draw [arrow] (conf) -- (instr);
  \draw [arrow] (instr) -- (filter);
  \draw [arrow] (filter) -- (gen);
  \draw [arrow] (gen) -- (test);
  \draw [arrow] (test) -- (report);
  \draw [arrow] (report) -- (dec);
  \draw [arrow] (dec) -- (propclean) node[near start, above] {Yes};
  \draw [arrow] (propclean) -- (printres);
  \draw [arrow] (printres) -- (finish);
  \draw [arrow] (dec) -| (clean) node[near start, above] {No};
  \draw [arrow] (clean) |- (gen);
  \end{tikzpicture}
  \caption{Flowchart showing each part of the framework and their connections.}
  \label{fig:frameworkdesign}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node [fsnode] {proj.root}
    child {node[fsnode] {tool\_config.json}}
    child {node [fsnode] {instr\_tool.sh}}
    child {node [fsnode] {run\_tool\_chroot.sh}}
    child {node [fsnode, optional] {tool.out}}
    child {node [fsnode] {chroot\_tmpl/}
      child {node [fsnode] {bionic/}}
      };
  \node [fsnode, xshift=5cm] {chroot.root}
    child {node [fsnode] {media/}
      child {node [fsnode] {success/}}
      child {node [fsnode] {flips/}}
    }
    child [missing] {}
    child [missing] {}
    child {node [fsnode] {tmp/}
      child {node [fsnode] {succ.file}}
    }
    child [missing] {}
    child {node [fsnode, optional] {run\_tool\_chroot.sh}};
\end{tikzpicture}
\caption{File system structure of framework and the chroot loaded for the test
runs, whereas the chroot is created from a templated loaded from the
\texttt{proj.root} and the \texttt{run\_tool\_chroot.sh} is copied over to the
created chroot.}
\label{fig:framfilesys}
\end{figure}

Each part of the framework is designed to work on its own and has a clearly
defined in- and output-interface. The parts can be adopted or easily used for
other testing purposes. The configuration file for the framework defines how
each step is applied to the application as instrumentation and verification may
differ for each program. The file in listing~\ref{lst:expconfig} shows an
example configuration file for the framework. Figure~\ref{fig:framfilesys} shows
the layout of the framework in the file system. The configuration file tells the
framework where to find each of the required files. The template chroot
describes the system used for testing.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=nasm,
                   caption={JSON style config file for the framework, showing
all parameters used to tweak each part of the framework. Entries
starting with \texttt{CR\_} are used inside the testing \texttt{chroot}.},
                   label={lst:expconfig}]
{
  "instrumenter_call": "./instr_tool.sh",
  "instrumenter_outfile": "tool.out",
  "chroot_template": "chroot_tmpl/bionic",
  "tmp_chroot_folder": "/media/ramdisk/chroot/",
  "folder_with_flips": "/media/ramdisk/flips/",
  "num_of_parallel_checks": 1,
  "CR_exec_file": "./run_tool_chroot.sh",
  "CR_flip_folder": "/media/flips",
  "CR_success_folder": "/media/success/",
  "CR_log_file": "/tmp/succ.file"
}
\end{lstlisting}
\end{minipage}

The framework starts with executing \texttt{instr\_tool.sh} to generate a report
showing all bitflips, additional it can also filter them. After the
script\textquotesingle s execution, the \texttt{tool.out}-file should contain a
list of all byte positions to flip and test. Afterwards, the defined number of
chroots are created by copying the template from \texttt{chroot\_tmpl}. The
configured flips are split and separately copied to each \texttt{/media/flips}
folder in the testing chroot. The \texttt{run\_tool\_chroot.sh} file is copied
to each testing environment and executed there. This script runs the tests with
all flips and reports successful flips to the framework.

\subsubsection{Instrumenting the Program}

We use Intel Pin~\cite{pintool} for instrumentation.  We log every memory access
during execution of the program. We want to log all accesses which happen
inside of ELF files, which means the program\textquotesingle s binary and all
libraries it uses during runtime. We use the same pintool for all test runs. It
simply adds instrumenter calls to all memory accesses. The tool stores all
accesses per file and what base-offsets are used. This information is required
to determine which accessed area is mapped to which file later on.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Example C++ code for a pintool logging memory
accesses. At first, the tool stores the instruction bytes, and after the
operands are stored separately, depending on if they are writing or reading
memory.},
                   label={lst:pinlogcode}]
ADDRINT ins_addr = INS_Address(ins);
IMG img = IMG_FindByAddress(ins_addr);
ADDRINT base = IMG_LowAddress(img);
img_offsets[base] = IMG_LoadOffset(img);

for(size_t i = 0; i < INS_Size(ins); i++)
  accesses.insert(std::make_pair(ins_addr + i, base));

UINT32 memOperands = INS_MemoryOperandCount(ins);
for (UINT32 memOp = 0; memOp < memOperands; memOp++)
{
  if(INS_MemoryOperandIsRead(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,
      IARG_INST_PTR,
      IARG_MEMORYREAD_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYREAD_SIZE,
      IARG_END);
  }
  if(INS_MemoryOperandIsWritten(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,
      IARG_INST_PTR,
      IARG_MEMORYWRITE_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYWRITE_SIZE,
      IARG_END);
  }
}
\end{lstlisting}
\end{minipage}

We instrument the program with a run resulting in a failed state, after the run,
we filter the accessed memory areas for each file and check if areas were
written before reading. If so, we can also skip testing those bits, as the
program would overwrite the flips again. Listing~\ref{lst:pinlogcode} shows a
code snippet of the used pintool which logs all memory accesses as it
instruments each instruction and logs the opcode position and its parameters if
they address memory. The listing~\ref{lst:pinlogcode} also shows some API-calls
for the PIN framework. In Pin, the image~\texttt{img} refers to a file on the
hard drive. In most cases, these refer to dynamically loaded libraries. The
\texttt{INS\_InsertPredicatedCall} function is used to insert a function call on
the machine code layer. The function can have an arbitrary number of parameters,
as the user have to define the function with each parameter and the type. Pin
then inserts a call to the given function pointer and manages the handling of
the parameters and return values in a way that the instrumented
program\textquotesingle s execution is not affected.

Instrumentation is done via the configured \texttt{instrumenter\_call}. That
entry is executed and expected to generate a file named in the
\texttt{instrumenter\_outfile} configuration parameter. This file needs to
follow an output format for the accesses as in \texttt{<hex:position\_in\_file>
- str:filename}. The framework then applies a filter to that before it tests the
actual bitflips.

\subsubsection{Filtering Memory Accesses reported by the Instrumentation}

We apply a filter to the memory accesses at two different points. At first, we
already filter inside the pintool. As we log reading and writing accesses to
memory separately, we can check on reading accesses if the program
has written to the position before, if so, there is no need to flip this
location in the binary.

At second, after the program run, we translate all reported accessed addresses
to positions in ELF files. At this point, every access which does not refer to
the file content is thrown away. We can do this as we store the base address of
each loaded library with the pintool.

Additionally, we add addresses of ELF structure headers, as remapping sections
or change other property bits inside the ELF structure can affect the way the
binary runs. After applying the filters, we gain a list of bytes to test.

\subsubsection{Generating and Testing the Flips}

Next, we create a new ELF file for each bit for each of the reported bytes. We
generate those files into a \texttt{tmpfs} file-system placing its memory in the
DRAM to have lower access times than to the hard drive. Depending on the
configured number of parallel checks, chroots are created in the \texttt{tmpfs}
too. The framework makes sure the number of created ELF files does not require
more than the memory available. If there are more files to test than the
available memory allows, the framework takes multiple runs, as seen in
figure~\ref{fig:frameworkdesign} describing the design. A test run starts
configured \texttt{CR\_exec\_file} which will copy a flipped file from
\texttt{CR\_flip\_folder} to the original position, then run it and check if the
output matches a defined success state. If the flipped file reaches the success
state, the framework writes the flipped address to \texttt{CR\_log\_file} and
copies the flipped ELF file to \texttt{CR\_success\_folder}. The framework
passes the file to replace to the \texttt{CR\_exec\_file} when it calls it. To
keep track of which bitflip is tested the filename for generated ELF files is
structured as \texttt{<original\_filename>\_<address\_in\_file>\_<bit\_number>}.

\subsubsection{Flipping bits in Binaries using Rowhammer}

Targeting files with Rowhammer is an improved attack on previously shown usages
of the vulnerability. Gruss~\etal~\cite{flipinthewall} showed, that besides
targeting page table entries, it is also possible to target shared libraries or
ELF files directly. With this work, the possible attack vector for Rowhammer
grew. To flip the bit in the binary using Rowhammer an attacker needs to make
sure the file is loaded to DRAM. For execution, the operating system loads the
ELF file in a defined structure to the memory. Targeting this loaded memory
might be hard for an attacker, as offsets inside the memory might be
randomised by ASLR. As we tested ELF files directly and not loaded program
images, the flips might be best directly applied to the ELF file.

Most operating systems use a disk cache. Meaning the OS will keep file content
in DRAM as long as the memory is not used elsewhere. When a file is opened the
system loads the content to the memory, which in case of loading an ELF would
put the entire file into the DRAM, making it possible to apply bitflips.
Therefore, a later call to the program would load the flipped version already
cached in DRAM.

Another idea would be to use Rowhammer on storage devices. As
Kurmus~\etal~\cite{rowssdhammer} showed it is possible to find a similar
behaviour as Rowhammer for solid-state drives (SSD). They refer to a problem in
MLC NAND chips, showing the possibility of a similar attack. They show that
corrupting a block inside the SSD is enough to gain privilege escalation. Such
an attack could also be used to flip bits inside the stored ELF files.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Finding Rowhammer-targets in real-world
Applications}\label{sec:results}

In our thesis, we want to apply our tool to more extensive programs, programs
used in the real world and with bitflips in mind which an attacker also would
use. As Gruss~\etal~\cite{flipinthewall} already showed, there are bits in the
\texttt{sudoers} library which when toggled, allow using \texttt{sudo} without
or with a wrong password to still gain super-user privilege. We show that our
framework can find a more significant number of possible bitflips to achieve
this. We present the results of our testing framework applied to real-world
programs, which are commonly used in Unix-based operating systems. This
subsection will present all our applications tested, if there were adaptions
made for instrumenting or testing, and the results for the bitflips are
presented. For each application, we present an example bitflip and discuss why
it caused switching to a successful state.

For the results, looking at the introduced bitflips in the code in
listing~\ref{lst:disasmsimplebranch}, we can see that permission checks can be
bypassed similarly for the programs we looked at. As at some point jump
instructions will point to code executed only in a positive state. We can also
see flips causing a success which change bits in other sections than the code
one. We want to show which ELF files have bits where flips would cause the
program to run into a state of success and what areas in ELF files are most
promising for flips to be found.

We used a \texttt{Debian GNU/Linux 9.5} operating system to run our tests. For
the testing-\texttt{chroot} we have chosen the same system. The CPU used was a
\texttt{Intel(R) Core(TM) i7 CPU 960} and the system provided a total of 16
gigabyte DRAM memory.

\section{\texttt{sudo} - Privilege Escalation}

For \texttt{sudo}, the task was to find all possible bitflips which allow
switching to \texttt{root}, without knowing the correct password of the base
user. \texttt{sudo} is a \texttt{setuid} binary, which changes its process
owner to \texttt{root} when being executed. We ran into problems with our
framework because of this property.

\subsection{Instrumentation}

For \texttt{sudo}, instrumentation became more advanced than for simple
programs, because of the way Pin works. Usually, when starting a program with a
pintool, Pin would modify the program\textquotesingle s memory to add its
internal instrumenter calls and then execute the program. As \texttt{sudo} is
owned by \texttt{root}, Pin is not allowed to modify the memory when running as
regular user. Running \texttt{sudo} with Pin attached as \texttt{root} is
possible, but starting \texttt{sudo} as super-user would not trigger the
password dialogue nor trigger any of the authentication-check-execution paths
as there is no need to change the current user.

To bypass this, we use the attach-to-process functionality of Pin, which
would not change the context of the program and still run it as a regular user.
The problem for this is, finding the program ID and attach to it takes time,
which allows us only to attach at the point where the password dialogue has
already popped-up. Pre-loading a wait library which keeps the process sleeping
resolves this issue, and we can instrument the relevant code of the binary.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Code of the pre-loaded library to keep the process
waiting for some milliseconds, which gives enough time for Pin to attach to the
process.},
label=lst:presleeplib]
extern const char *__progname;

__attribute__((constructor)) void init(void)
{
  if(!strcmp(__progname, "sudo_instr"))
  {
    size_t i = 0;
    while(i++ < 600000000);
  }
}
\end{lstlisting}
\end{minipage}

Listing~\ref{lst:presleeplib} shows the code used to generate such a pre-loaded
library. We use the counting while-loop instead of a call to the sleep system
call because attaching Pin to a process in sleeping state results in a state
where the process cannot wake up again. This is a general problem with
GNU/Linux environments and is also a problem for other debuggers, such as
\texttt{gdb}. The number of increments was chosen to have enough time to
search the process ID and attach to it. The compiler attribute
\texttt{constructor} makes sure the program executes this code on loading the
library before any other code. We use the \texttt{/etc/ld.so.preload} file to
make our library load for any program. To not have all programs waiting on
start-up, we check the name of the binary before entering the loop.

\subsection{Testing}

Checking successful behaviour for the \texttt{sudo} program is easy, we call it
and provide it a wrong password. There are multiple ways to verify a successful
privilege change. For once, it is possible to use the \texttt{whoami} program
to check if the system changed the current user to \texttt{root}. On the other
side, it is also possible to verify by reading a file owned by the super-user.

\subsection{Results}

Table~\ref{tab:sudores} shows the number of found flips per file. We see that
the possible flips are spread over multiple files. The \texttt{sudoers} library
contains most of them, whereas we also can find flips affecting a privilege
change in the linker (\texttt{ld-linux}) and the threading library
(\texttt{libpthread}). As expected, most flips are in the \texttt{.text}
section. Additionally, other main sections such as \texttt{.rodata} contain
flips. The \texttt{.plt} section refers to the Procedure Linkage Table, which is
used to resolve mappings between position-independent functions and their
absolute addresses. Close to the same is the \texttt{.got.plt} section, which
represents the global offset table, which resolves mappings for position
independent code parts.

\begin{table}[!htb]
\centering
\begin{tabular}{c|cccc|c}
ELF File & \texttt{.text}  & \texttt{.rodata} & \texttt{.got.plt} &
\texttt{.plt} & Sum of flips:                             \\ \hline
\texttt{ld-linux-x86-64.so.2} & 1   & 0  & 0  & 0  & 1    \\
\texttt{libpthread.so.0}      & 2   & 0  & 0  & 0  & 2    \\
\texttt{sudo}                 & 6   & 0  & 0  & 0  & 6    \\
\texttt{libnns\_compat.so.2}  & 6   & 0  & 1  & 0  & 7    \\
\texttt{libpam.so.0}          & 64  & 0  & 0  & 0  & 64   \\
\texttt{pam\_unix.so}         & 85  & 0  & 0  & 1  & 86   \\
\texttt{sudoers.so}           & 219 & 35 & 5  & 0  & 259  \\ \hline
Sum of flips:                 & 383 & 35 & 6  & 1  & 425
\end{tabular}
\caption{List of ELF files used by the \texttt{sudo(1.8.19p1)} program and the
number of flips causing privilege escalation listed per section.}
\label{tab:sudores}
\end{table}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to \texttt{libnss} in
order to bypass a user privilege check. The call to \texttt{strcmp} is
replaced because of the offset in the lookuptable being one off.},
label=lst:sudoex]
     351b:      0f 84 90 00 00 00       je     35b1
     3521:      48 89 ee                mov    %rbp,%rsi
-    3524:      e8 47 dc ff ff          callq  1170 <strcmp@plt>
+    3524:      e8 c7 dc ff ff          callq  11f0 <malloc@plt>
     3529:      85 c0                   test   %eax,%eax
     352b:      0f 85 3e ff ff ff       jne    346f
\end{lstlisting}
\end{minipage}

In listing~\ref{lst:sudoex}, we show a diff for \texttt{libnss} where a call to
\texttt{strcmp} is replaced with a call to \texttt{malloc} by a single bitflip,
causing the later \texttt{jne} instruction to behave differently.

Testing the \texttt{sudo} ELF files took a total of about eight hours time.
This is less than half of the time it would need to test all possible bytes. We
have used twenty-four parallel test runs on our described testing environment.

\section{\texttt{nginx} - HTTP Basic Authentication Bypass}

For \texttt{nginx} we want to achieve an HTTP basic authentication bypass by
flipping a single bit. This means we have to set up a page which is only
accessible given a correct user and password credential pair.

\subsection{Instrumentation}

Instrumenting \texttt{nginx} is straightforward. We had to modify the default
configuration of the web server a little to make sure the server runs as a
single process. This was done by not allowing \texttt{nginx} to run as a system
daemon or make use of a master process. We also only want to instrument the code
run when an actual request to the protected site happens. Therefore, we again
use the functionality to attach Pin to an already running process. For
instrumentation, we start the web server, attach Pin, sent a request to the
protected site with wrong credentials, wait for the denying answer from the
server and then end instrumentation. This should give us only the memory
accessed during a basic authentication request.

\subsection{Testing}

Verifying successful bitflips in \texttt{nginx} works the same as in the
instrumentation. We copy the flipped ELF, start the server, verify it is running
by requesting a standard page, then requesting the protected site with wrong
credentials, a successful state is reached if the web server returns the
protected site to a request with wrong credentials. For requesting the
protected site, we use \texttt{netcat} instead of \texttt{curl} or
\texttt{wget}, as we only want to make sure the content is delivered to us and
not if the HTTP reply got malformed in any way by the bitflip. We use different
HTTP ports per server, equal to the ID of the chroot, to avoid startup problems
during testing as the same port would be used more often otherwise, which is
not possible.

\subsection{Results}

For the basic authentication bypass in \texttt{nginx} we can report that only
flips inside the program\textquotesingle s binary itself were useable.
Table~\ref{tab:nginxres} shows the number of flips found and that all flips are
inside the \texttt{.text} section of the \texttt{nginx} binary.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & \texttt{.text} \\ \hline
\texttt{nginx}         & $298$
\end{tabular}
\caption{List of flips inside the \texttt{nginx(1.10.3)} program causing a
basic authentication bypass, whereas all of them were in the \texttt{.text}
section.}
\label{tab:nginxres}
\end{table}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to the \texttt{nginx}
binary in order to bypass a credential check. The call to \texttt{test} is
replaced by \texttt{add} which doesn't chage a register the \texttt{setne}
instruction would check.},
label=lst:nginxex]
    3c935:      48 83 c0 01             add    $0x1,%rax
    3c939:      0f b6 10                movzbl (%rax),%edx
-   3c93c:      84 d2                   test   %dl,%dl
+   3c93c:      04 d2                   add    $0xd2,%al
    3c93e:      0f 95 c1                setne  %cl
    3c941:      80 fa 24                cmp    $0x24,%dl
\end{lstlisting}
\end{minipage}

In listing~\ref{lst:nginxex}, we show a diff for the \texttt{nginx} binary, the
flip in this example changes a call to \texttt{test} to \texttt{add}. The
instruction afterwards is \texttt{setn}, used to set a byte if the condition,
in this case ``not equal'', is met. As \texttt{add}
does not affect the \texttt{ZF} register, which the \texttt{setn} checks, the
code is likely to behave differently.

Testing the \texttt{nginx} ELF files took a total of about eighteen hours time.
The timing is that high cause we had to make sure the server is up and ready to
reply to our requests for each test. For testing, we have used eight parallel
testing instances.

\section{\texttt{sshd} - Secure Shell Server Login Bypass}

For the \texttt{ssh}-server, our goal is to achieve a login without knowing the
correct password. We configure our test environment with an additional user,
which allows remote logins via password. On a successful connection, the secure
shell \texttt{ssh} should be able to execute commands inside the test
environment.

\subsection{Instrumentation}

Instrumenting \texttt{sshd} is very similar to \texttt{nginx}, it is possible to
run the \texttt{ssh}-server without super-user privileges. We instrument only
the code ran during a request, because usually the \texttt{ssh}-daemon is
started during the boot procedure and never exited. We attach Pin to the running
server, try to connect with a correct username but a wrong password, wait for
the denying answer from the server and stop instrumentation.  With this, we
should get exactly the memory accesses necessary used to verify user
credentials.

\subsection{Testing}

Verifying the success state is straightforward. We copy the flipped binary,
start the server and wait for some seconds for the startup to complete. To
verify the success state, we try to connect to the remote server with a wrong
password and attempt to execute \texttt{whoami}. This should return the username
from the credentials used to connect. We tested the \texttt{OpenSSH\_7.4p1
Debian-10+deb9u4} version of the server and client, both used the OpenSSL
version \texttt{1.0.2l}.

\subsection{Results}

For the used \texttt{ssh} server we can only report working bitflips in the
loaded libraries. Additional, all of the reported flips were found in the
\texttt{.text} section of the ELF files. Table~\ref{tab:sshdres} gives an
overview of the number of flips found per file. We can see, that most bitflips
can be found in the \texttt{libc} of the host system, also the cryptographic
library and the linker are affected for Rowhammer targeting a \texttt{ssh}
login.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & \texttt{.text} \\ \hline
\texttt{libc.so.6}         & $34$ \\
\texttt{libcrypto.so.1.0.2} & $6$ \\
\texttt{ld-linux-x86-64.so.2} & $1$ \\ \hline
Sum of flips:                 & $41$
\end{tabular}
\caption{List of flips inside the \texttt{sshd(7.4p1)} program
causing a authentication bypass, whereas all of them were in the \texttt{.text}
sections of dynamically loaded libraries.}
\label{tab:sshdres}
\end{table}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to the
\texttt{libcrypto.so.1.0.2} binary in order to bypass a credential check. The
move from \texttt{rbx} to \texttt{rdi} is exchanged with a move to
\texttt{r15}, this changes the parameter for \texttt{EVP\_MD\_CTX\_test\_flags},
which is highly likely to result in a different outcome.},
label=lst:sshdex]
   1341c5:      74 ad                  je     134174 <EVP_MD_CTX_cleanup>
   1341c7:      be 04 00 00 00         mov    $0x4,%esi
-  1341cc:      49 89 df               mov    %rbx,%rdi
+  1341cc:      48 89 df               mov    %rbx,%r15
   1341cf:      e8 dc e5 f3 ff         callq  727b0 <EVP_MD_CTX_test_flags@plt>
   1341d4:      85 c0                  test   %eax,%eax
\end{lstlisting}
\end{minipage}

In listing~\ref{lst:sshdex}, we show a diff for the \texttt{libcrypto} library
used by \texttt{ssh}. We can see how changing the function parameters
(\texttt{rdi}) for \texttt{EVP\_MD\_CTX\_test\_flags@plt} changes the outcome
of the libary call in a way ssh will think it is working with correct
credentials.

Testing the \texttt{ssh} server took about six hours. The timing here is lower
than for \texttt{nginx} or \texttt{sudo}, as the shell server was faster ready
than \texttt{nginx}, and there were not so many flips to test as in
\texttt{sudo}.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
