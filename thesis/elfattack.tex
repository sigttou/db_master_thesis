%%%%%% Static Data Flips %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Bitflip Attacks on ELF Files}\label{sec:elfattack}

In this chapter, we present a novel to automate finding bitflips in ELF which
yield exploitable execution path changes. Gruss~\etal~\cite{flipinthewall}
already have shown a similar approach by disassembling binaries and manually
looking for exploitable bitflips. We start by discussing their approach and
point out the downsides of the manual search.

Then we describe our task and the framework we created to find exploitable
bitflips in binaries to change their behaviour to a pre-defined state. We start
with a general overview of the framework design and go on with discussing the
details on how we find bits to check, how the definition for searching works,
how we test the bitflips and how results are captured and verified.

\section{Analysing the Manual Search Approach}

Gruss~\etal~\cite{flipinthewall} introduce so-called opcode flipping to bypass
the Rowhammer countermeasure of physical kernel memory isolation, which was
proposed as a countermeasure to prevent bitflips in page tables. With opcode
flipping, it is possible to gain privilege escalation by flipping pages which
hold executable code. Gruss~\etal~\cite{flipinthewall} describe their approach
as follows. First, a memory area in the binary is defined, which holds bits to
test with flipping. Secondly, all bits in the defined area are flipped,
resulting binaries are executed, and grouped by the outcoming results. In the
end, the results are analysed manually, and exploitable behaviours are noted and
then attacked with Rowhammer. Gruss~\etal~\cite{flipinthewall} show a case study
of this approach where the \texttt{sudo} program is analysed and report \SI{29}
bitflips which give an attacker root permissions without knowing the
user\textquotesingle s password.

As this approach seems feasible, we claim that it is not practical.
Gruss~\etal~\cite{flipinthewall} analysed the program\textquotesingle s binary,
and the dynamically loaded libraries to identify targetable memory areas, by
this choice, areas might be missed. Also, each bit in a defined area is tested,
which could include bits of memory which is never executed during the
program\textquotesingle s run. Manually analysing the results may take much time
and might not be feasible for a larger number of bitflips. Besides flipping
opcodes, also prefixes and parameters of instructions should be tested for
bitflips. Also, not only specific memory areas holding executable code should be
tested but all memory in binaries accessed during the runtime of the program. As
Gruss~\etal~\cite{flipinthewall} only check a specific version of a program,
the reported bitflips might not work in a newer version, and the same work has
to be done again.

\section{Automating the Finding of Feasible Bitflips}

Flipping all bits inside a binary, reporting each output and check for a
successful outcome might be a way to generate a list of all exploitable
bitflips. Looking at the compiled binary from Listing~\ref{lst:csimbranch}, in
Section~\ref{sec:motivation}, it would result in a \SI{8288}{\byte} file.
Following the approach of testing all possible bits, would result in \SI{66304}
bitflips to test. With an execution time of approximately \SI{0.003}{\second}, a
complete test run would take close to \SI{200}{\second}.

Looking at \texttt{sudo}, the ELF file of the program alone has
\SI{149080}{\byte}, without dynamic libraries, and the execution time is around
\SI{0.03}{\second}. The same approach applied to \texttt{sudo} would, therefore,
take around \SI{35780}{\second}, which is approximately \SI{10}{\hour}. Such a
long time is not feasible, as dynamic libraries used also need to be tested.
Including those libraries, would result in \SI{3219208}{\byte}, which would
require approximately \SI{215}{\hour} or \SI{9} days.

Four our automation of the exploitable bitflip search, we want to require way
less time than with the test all bit approach, as we want to target larger
real-world applications.

\subsection{Design of the Testing Framework}

\begin{figure}
  \centering
  \begin{tikzpicture}
  % Nodes of the framework
  \node (start) [root] {Start};
  \node (conf) [function, right of=start, xshift=2cm] {Load config};
  \node (instr) [function, right of=conf, align=center, xshift=2cm]
                {Instrument \\ binary};
  \node (filter) [function, right of=instr, align=center, xshift=2cm]
                 {Filter \\ memory areas};
  \node (gen) [function, below of=filter, align=center, yshift=-1cm]
              {Generate \\ flipped binaries};
  \node (test) [function, below of=gen, align=center, yshift=-1cm]
               {Test \\ generated files};
  \node (report) [function, below of=test, align=center, yshift=-1cm]
                 {Log results};
  \node (clean) [function, right of=report, align=center, xshift=2cm]
                {Delete \\ generated files};
  \node (dec) [decision, below of=report, align=center, yshift=-1cm]
              {Finished?};
  \node (propclean) [function, left of=dec, align=center, xshift=-2cm]
                    {Cleanup \\ Testing \\ Environment};
  \node (printres) [function, left of=propclean, align=center, xshift=-2cm]
                   {Print Results};
  \node (finish) [finish, left of=printres, xshift=-2cm] {Done};
  % Connections
  \draw [arrow] (start) -- (conf);
  \draw [arrow] (conf) -- (instr);
  \draw [arrow] (instr) -- (filter);
  \draw [arrow] (filter) -- (gen);
  \draw [arrow] (gen) -- (test);
  \draw [arrow] (test) -- (report);
  \draw [arrow] (report) -- (dec);
  \draw [arrow] (dec) -- (propclean) node[near start, above] {Yes};
  \draw [arrow] (propclean) -- (printres);
  \draw [arrow] (printres) -- (finish);
  \draw [arrow] (dec) -| (clean) node[near start, above] {No};
  \draw [arrow] (clean) |- (gen);
  \end{tikzpicture}
  \caption{Flowchart showing each part of the framework and their connections.}
  \label{fig:frameworkdesign}
\end{figure}

We have implemented a framework to search for exploitable bitflips in programs.
Figure~\ref{fig:frameworkdesign} shows a diagram describing the
framework\textquotesingle s design. We split it into multiple parts:

\begin{enumerate}
\begin{samepage}
  \item Accessed memory areas are logged from all the ELF files the program
uses.
  \item Pre-defined filters are applied to the reported memory areas.
  \item ELF files for each of the bit flips are generated.
  \item Each ELF file gets executed, and the behaviour is checked against a
pre-defined success state
\end{samepage}
\end{enumerate}

\begin{figure}
\centering
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node [fsnode] {proj.root}
    child {node[fsnode] {tool\_config.json}}
    child {node [fsnode] {instr\_tool.sh}}
    child {node [fsnode] {run\_tool\_chroot.sh}}
    child {node [fsnode, optional] {tool.out}}
    child {node [fsnode] {chroot\_tmpl/}
      child {node [fsnode] {bionic/}}
      };
  \node [fsnode, xshift=5cm] {chroot.root}
    child {node [fsnode] {media/}
      child {node [fsnode] {success/}}
      child {node [fsnode] {flips/}}
    }
    child [missing] {}
    child [missing] {}
    child {node [fsnode] {tmp/}
      child {node [fsnode] {succ.file}}
    }
    child [missing] {}
    child {node [fsnode, optional] {run\_tool\_chroot.sh}};
\end{tikzpicture}
\caption{File system structure of the framework and the chroot loaded for the
test runs, whereas the chroot is created from a templated loaded from the
\texttt{proj.root} and the \texttt{run\_tool\_chroot.sh} is copied over to the
created chroot.}
\label{fig:framfilesys}
\end{figure}

Each part of the framework is designed to work on its own and has a clearly
defined in- and output-interface. The parts can be adopted or easily used for
other testing purposes. The configuration file for the framework defines how
each step is applied to the application, as instrumentation and verification may
differ for each program. The file in Listing~\ref{lst:expconfig} shows an
example configuration file for the framework. Figure~\ref{fig:framfilesys} shows
the layout of the framework in the file system. The configuration file tells the
framework where to find each of the required files. The template chroot
describes the system used for testing.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=nasm,
                   caption={JSON style config file for the framework, showing
all parameters used to tweak each part of the framework. Entries
starting with \texttt{CR\_} are used inside the testing \texttt{chroot}.},
                   label={lst:expconfig}]
{
  "instrumenter_call": "./instr_tool.sh",
  "instrumenter_outfile": "tool.out",
  "chroot_template": "chroot_tmpl/bionic",
  "tmp_chroot_folder": "/media/ramdisk/chroot/",
  "folder_with_flips": "/media/ramdisk/flips/",
  "num_of_parallel_checks": 1,
  "CR_exec_file": "./run_tool_chroot.sh",
  "CR_flip_folder": "/media/flips",
  "CR_success_folder": "/media/success/",
  "CR_log_file": "/tmp/succ.file"
}
\end{lstlisting}
\end{minipage}

The framework starts with executing \texttt{instr\_tool.sh} to generate a report
showing all bitflips to test. Additionally, it can also filter them. After the
script\textquotesingle s execution, the \texttt{tool.out}-file contains a list
of all byte positions to flip and test. Afterwards, the defined number of
chroots are created by copying the template from \texttt{chroot\_tmpl}. The
flipped binaries are copied to each \texttt{/media/flips} folder in the testing
chroot. The \texttt{run\_tool\_chroot.sh} file is copied to each testing
environment and executed there. This script runs in each of the \texttt{chroot},
replaces the original binary with a flipped version, runs the configured program
and checks it\textquotesingle s outcome. If the outcome matches a pre-defined
success state, the flipped binary is stored and reported by the framework after
all test runs are finished.

\subsubsection{Instrumenting the Program}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Example C++ code for a pintool logging memory
accesses. The tool stores the locations of instructions and parameters if they
point to memory. The tool stores accesses for reading and writing seperately.},
                   label={lst:pinlogcode}]
ADDRINT ins_addr = INS_Address(ins);
IMG img = IMG_FindByAddress(ins_addr);
ADDRINT base = IMG_LowAddress(img);
img_offsets[base] = IMG_LoadOffset(img);

for(size_t i = 0; i < INS_Size(ins); i++)
  accesses.insert(std::make_pair(ins_addr + i, base));

UINT32 memOperands = INS_MemoryOperandCount(ins);
for (UINT32 memOp = 0; memOp < memOperands; memOp++)
{
  if(INS_MemoryOperandIsRead(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,
      IARG_INST_PTR,
      IARG_MEMORYREAD_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYREAD_SIZE,
      IARG_END);
  }
  if(INS_MemoryOperandIsWritten(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,
      IARG_INST_PTR,
      IARG_MEMORYWRITE_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYWRITE_SIZE,
      IARG_END);
  }
}
\end{lstlisting}
\end{minipage}

We use Intel Pin~\cite{pintool} for instrumentation. We log every memory access
during execution of the program. We want to log all accesses which happen inside
of ELF files, which means the program\textquotesingle s binary and all libraries
it uses during runtime. The pintool we use to achieve this, adds instrumenter
calls to all memory accesses. The tool then logs all accesses per binary and the
offsets of the address in the corresponding ELF file. This information is
required to determine which accessed area is mapped to which file later on.

Listing~\ref{lst:pinlogcode} shows a code snippet of the used pintool which
logs all memory accesses as it instruments each instruction and logs the opcode
position and its parameters if they address memory. For Pin, the
image~\texttt{img} refers to an ELF file stored on the hard drive, the images
represent the program\textquotesingle executable and the dynamic libraries
loaded during execution. The \texttt{INS\_InsertPredicatedCall} function is used
to insert a function call on the machine code layer. The function can have an
arbitrary number of parameters, as the user has to define the function with each
parameter and type. Pin then inserts a call to the given function pointer and
manages the handling of the parameters and return values in a way that the
instrumented program\textquotesingle s execution is not affected.

We instrument the program with a run resulting in a failed state, after the run,
we filter the accessed memory areas for each file and check if areas were
written before reading. If so, we can also skip testing those bits, as the
program would overwrite the flips again.

Instrumentation is done via the configured \texttt{instrumenter\_call} in the
config file shown in Listing~\ref{lst:expconfig}. The
\texttt{instrumenter\_call} generates the configured
\texttt{instrumenter\_outfile}. The output file contains the memory accesses
formated in the following manner:

\mbox{\texttt{<hex:position\_in\_file> - str:filename}}.

\subsubsection{Generating and Testing the Flips}

Next, we create a new ELF file for each bit for each of the reported bytes.
Depending on the configured number of parallel checks, chroots are created. The
framework makes sure the number of created ELF files does not require more than
the memory available. If there are more files to test than the available memory
allows, the framework takes multiple runs, as shown in
Figure~\ref{fig:frameworkdesign}. A test run starts configured
\texttt{CR\_exec\_file} which will copy a flipped file from the
\texttt{CR\_flip\_folder} to the original position, then run it and check if the
output matches a defined success state. If the flipped file reaches the success
state, the framework writes the flipped address to the \texttt{CR\_log\_file}
and copies the flipped ELF file to the \texttt{CR\_success\_folder}. The
framework passes the file to replace to the \texttt{CR\_exec\_file} when it
calls it. To keep track of which bitflip is tested the filename for generated
ELF files is structured as follows:

\mbox{\texttt{<original\_filename>\_<address\_in\_file>\_<bit\_number>}}.

\subsection{Tweaks added to the Framework}

As our framework reports all accessed memory areas, we apply some tweaks to
these reported memory areas generated with Pin. The additions help us to either
filter unnecessary flips and also to add memory areas which would be missed by
instrumentation as they are only accessed during the setup phase of the program.

\subsubsection{Filtering Memory Accesses}

As seen in Listing~\ref{lst:pinlogcode} we log accesses separated by reading and
writing. This separation is done to apply a simple filter on the reported memory
areas. It is not practical to test a memory area which is written before being
read, as the program will overwrite the memory area before a bitflip would
influence the execution path. We, therefore, test memory areas which are either
only read or read before write access.

\subsubsection{Testing flips in the ELF structure}

As described in Section~\ref{sec:elf}, the ELF structure contains information
for the linker on where to load different segments of the binary in the virtual
address space. Applying flips in this section could lead to misplaced libraries
or different offsets for segment mappings. A call of a function might result in
executing different code as intended and lead to a different outcome of the
program. Therefore, we also test each bit which is used for representing ELF
structures.

\subsubsection{Instrumenting Binaries running as superuser}

Some binaries behave differently when being run by a superuser. For example
\texttt{sudo} is a \texttt{setuid} binary owned by \texttt{root}, therefore the
active user running the binary is \texttt{root}. If Pin is running as a regular
user, it is not allowed to access the memory of a superuser\textquotesingle s
process, it, therefore, cannot instrument \texttt{sudo}. Running Pin as
superuser is possible, but starting \texttt{sudo} as \texttt{root} does not
trigger any authentication checks, as the calling user already got superuser
permissions, therefore a change of the current user is not required.

We use the attach-to-process functionality of Pin to bypass this behaviour. In
that way, we can start \texttt{sudo} as a regular user and run Pin as superuser.
We would start \texttt{sudo} and then attach to the resulting process ID. The
problem here is that getting the process ID takes time and during that time
\texttt{sudo} could already perform accesses which then would be missed by
instrumentation. Therefore, we preload a shared library which keeps the
\texttt{sudo} program in a defined state for some time to give the framework
enough time to look up the ID and instrument all relevant code parts.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Code of the preloaded library to keep the process
waiting for some milliseconds, which gives enough time for Pin to attach to the
process.},
label=lst:presleeplib]
extern const char *__progname;

__attribute__((constructor)) void init(void)
{
  if(!strcmp(__progname, "instrumented_program"))
  {
    size_t i = 0;
    while(i++ < 600000000);
  }
}
\end{lstlisting}
\end{minipage}

Listing~\ref{lst:presleeplib} shows the code used to generate such a preloaded
library. We use the counting while-loop instead of a call to the sleep system
call because attaching Pin to a process in sleeping state results in a state
where the process cannot wake up again. We also experienced the same issue with
debugging tools on our Linux-based environment, such as \texttt{gdb}. The number
of increments was chosen to have enough time to search the process ID and attach
to it. The compiler attribute \texttt{constructor} makes sure the program
executes this code on loading the library before any other code. We add the path
to our library to the \texttt{/etc/ld.so.preload} file, which makes sure the
library is preloaded by any executed program. The name of the executable is
checked in Line 5 of Listing~\ref{lst:presleeplib} to only call the while-loop
when the binary is our instrumentation target. Otherwise, all executed programs
would execute the time-consuming while-loop during startup.

\subsection{Comparing our Approach to other Techniques}

Our described approach for finding exploitable bitflips is built on a
fuzzing-like approach. We want to look at other ideas we tried to adapt or use
for the searching and argument on why we stuck with our described framework.

\subsubsection{Symbolic Execution}

\texttt{angr}~\cite{angrpaper} offers many tools and functions for binary
analysis and symbolic execution. For this, it can load a binary, search all
possible states and provides locations in the executable where a state has more
than one possible successor. \texttt{angr} allows searching for inputs and
arguments which would end up in a state defined as successful. This state could
either be defined by an address reached during execution or on the output of the
program. The approach \texttt{angr} seems useful for our task of searching
bitflips to change to a success state. However, \texttt{angr} is very limited
when changing the executed machine code to find new states. It works well for
finding inputs for the program to result in a success state. Testing bitflips
with \texttt{angr} results in a limited application of the tool\textquotesingle
s possibilities, where the binary is loaded, a bitflip is applied, and a single
run is made which is then checked if it ends up in the defined success state.
Changing inputs or arguments will not be tested. \texttt{angr} could be used to
test bitflips, but the time needed would be about \SI{10} to \SI{15} times
larger than our approach, because of the time it takes \texttt{angr} to load and
the program and its libraries.

\subsubsection{Using AFL}

Fuzzers like AFL~\cite{aflweb} tests a program by applying different forms of
input and generate those applying a form of edge coverage to learn from changes
from the control flow. AFL uses instrumentation to document the
program\textquotesingle s control flow and adapt its test cases based on changes
of it. AFL offers source code based instrumentation, which might not be suitable
for testing bitflips in binaries as with that approach, the tested executables
would change. According to their documentation~\cite{aflreadme}, AFL also offers
instrumentation of binary-only application. Here they use the QEMU processor
emulator~\cite{qemuweb} as a userland virtual machine. They state in Section 4
of the documentation~\cite{aflreadme} that in this mode execution is 2-5 times
slower than for the compile-time instrumentation approach.

For testing bitflips, the adaption of test cases can be ignored, as we always
stick to the same environment and external inputs. The AFL techniques to learn
from control flow changes could be adapted but as we do not want to build on
source-based instrumentation because of binary changes the additional execution
time for their binary instrumentation made the AFL adaption not practical.

\subsubsection{Using a Fuzzing like Apprach}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Case Study: Rowhammer-targets in real-world Applications}
\label{sec:results}

In our thesis, we want to apply our tool to more extensive programs, programs
used in the real world and with bitflips in mind which an attacker also would
use. As Gruss~\etal~\cite{flipinthewall} already showed, there are bits in the
\texttt{sudoers} library which when toggled, allow using \texttt{sudo} without
or with a wrong password to still gain super-user privilege. We show that our
framework can find a more significant number of possible bitflips to achieve
this. We present the results of our testing framework applied to real-world
programs, which are commonly used in Linux-based operating systems. This
subsection will present all our applications tested, if there were adaptions
made for instrumenting or testing, and the results for the bitflips are
presented. For each application, we present an example bitflip and discuss why
it caused switching to a successful state.

For the results, looking at the introduced bitflips in the code in
Listing~\ref{lst:disasmsimplebranch}, we can see that permission checks can be
bypassed similarly for the programs we looked at. As at some point jump
instructions will point to code executed only in a positive state. We can also
see flips causing a success which change bits in other sections than the code
one. We want to show which ELF files have bits where flips would cause the
program to run into a state of success and what areas in ELF files are most
promising for flips to be found.

We used a \texttt{Debian GNU/Linux 9.5} operating system to run our tests. For
the testing-\texttt{chroot} we have chosen the same system. The CPU used was a
\texttt{Intel(R) Core(TM) i7 CPU 960} and the system provided a total of
\SI{16}{\giga\byte} DRAM memory.

\section{\texttt{sudo} - Privilege Escalation}

For \texttt{sudo}, the task was to find all possible bitflips which allow
switching to \texttt{root}, without knowing the correct password of the base
user. \texttt{sudo} is a \texttt{setuid} binary, which changes its process
owner to \texttt{root} when being executed. We ran into problems with our
framework because of this property.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Instrumentation}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

For \texttt{sudo}, instrumentation became more advanced than for simple
programs, because of the way Pin works. Usually, when starting a program with a
pintool, Pin would modify the program\textquotesingle s memory to add its
internal instrumenter calls and then execute the program. As \texttt{sudo} is
owned by \texttt{root}, Pin is not allowed to modify the memory when
running as regular user. Running \texttt{sudo} with Pin attached as
\texttt{root} is possible, but starting \texttt{sudo} as super-user would not
trigger the password dialogue nor trigger any of the
authentication-check-execution paths as there is no need to change the current
user.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Testing}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

Checking successful behaviour for the \texttt{sudo} program is easy, we call it
and provide it a wrong password. There are multiple ways to verify a successful
privilege change. For once, it is possible to use the \texttt{whoami} program
to check if the system changed the current user to \texttt{root}. On the other
side, it is also possible to verify by reading a file owned by the super-user.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Results}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

Table~\ref{tab:sudores} shows the number of found flips per file. We see that
the possible flips are spread over multiple files. The \texttt{sudoers} library
contains most of them, whereas we also can find flips affecting a privilege
change in the linker (\texttt{ld-linux}) and the threading library
(\texttt{libpthread}). As expected, most flips are in the \texttt{.text}
section. Additionally, other main sections such as \texttt{.rodata} contain
flips. The \texttt{.plt} section refers to the Procedure Linkage Table, which is
used to resolve mappings between position-independent functions and their
absolute addresses. Close to the same is the \texttt{.got.plt} section, which
represents the global offset table, which resolves mappings for position
independent code parts.

\begin{table}[!htb]
\centering
\begin{tabular}{c|cccc|c}
ELF File & \texttt{.text}  & \texttt{.rodata} & \texttt{.got.plt} &
\texttt{.plt} & Sum of flips:                             \\ \hline
\texttt{ld-linux-x86-64.so.2} & 1   & 0  & 0  & 0  & 1    \\
\texttt{libpthread.so.0}      & 2   & 0  & 0  & 0  & 2    \\
\texttt{sudo}                 & 6   & 0  & 0  & 0  & 6    \\
\texttt{libnns\_compat.so.2}  & 6   & 0  & 1  & 0  & 7    \\
\texttt{libpam.so.0}          & 64  & 0  & 0  & 0  & 64   \\
\texttt{pam\_unix.so}         & 85  & 0  & 0  & 1  & 86   \\
\texttt{sudoers.so}           & 219 & 35 & 5  & 0  & 259  \\ \hline
Sum of flips:                 & 383 & 35 & 6  & 1  & 425
\end{tabular}
\caption{List of ELF files used by the \texttt{sudo(1.8.19p1)} program and the
number of flips causing privilege escalation listed per section.}
\label{tab:sudores}
\end{table}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to \texttt{libnss} in
order to bypass a user privilege check. The call to \texttt{strcmp} is
replaced because of the offset in the lookuptable being one off.},
label=lst:sudoex]
     351b:      0f 84 90 00 00 00       je     35b1
     3521:      48 89 ee                mov    %rbp,%rsi
-    3524:      e8 47 dc ff ff          callq  1170 <strcmp@plt>
+    3524:      e8 c7 dc ff ff          callq  11f0 <malloc@plt>
     3529:      85 c0                   test   %eax,%eax
     352b:      0f 85 3e ff ff ff       jne    346f
\end{lstlisting}
\end{minipage}

In Listing~\ref{lst:sudoex}, we show a diff for \texttt{libnss} where a call to
\texttt{strcmp} is replaced with a call to \texttt{malloc} by a single bitflip,
causing the later \texttt{jne} instruction to behave differently.

Testing the \texttt{sudo} ELF files took a total of about eight hours time.
This is less than half of the time it would need to test all possible bytes. We
have used twenty-four parallel test runs on our described testing environment.

\section{\texttt{nginx} - HTTP Basic Authentication Bypass}

For \texttt{nginx} we want to achieve an HTTP basic authentication bypass by
flipping a single bit. This means we have to set up a page which is only
accessible given a correct user and password credential pair.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Instrumentation}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

Instrumenting \texttt{nginx} is straightforward. We had to modify the default
configuration of the web server a little to make sure the server runs as a
single process. This was done by not allowing \texttt{nginx} to run as a system
daemon or make use of a master process. We also only want to instrument the code
run when an actual request to the protected site happens. Therefore, we again
use the functionality to attach Pin to an already running process. For
instrumentation, we start the web server, attach Pin, sent a request to the
protected site with wrong credentials, wait for the denying answer from the
server and then end instrumentation. This should give us only the memory
accessed during a basic authentication request.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Testing}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

Verifying successful bitflips in \texttt{nginx} works the same as in the
instrumentation. We copy the flipped ELF, start the server, verify it is running
by requesting a standard page, then requesting the protected site with wrong
credentials, a successful state is reached if the web server returns the
protected site to a request with wrong credentials. For requesting the
protected site, we use \texttt{netcat} instead of \texttt{curl} or
\texttt{wget}, as we only want to make sure the content is delivered to us and
not if the HTTP reply got malformed in any way by the bitflip. We use different
HTTP ports per server, equal to the ID of the chroot, to avoid startup problems
during testing as the same port would be used more often otherwise, which is
not possible.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Results}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

For the basic authentication bypass in \texttt{nginx} we can report that only
flips inside the program\textquotesingle s binary itself were useable.
Table~\ref{tab:nginxres} shows the number of flips found and that all flips are
inside the \texttt{.text} section of the \texttt{nginx} binary.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & \texttt{.text} \\ \hline
\texttt{nginx}         & $298$
\end{tabular}
\caption{List of flips inside the \texttt{nginx(1.10.3)} program causing a
basic authentication bypass, whereas all of them were in the \texttt{.text}
section.}
\label{tab:nginxres}
\end{table}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to the \texttt{nginx}
binary in order to bypass a credential check. The call to \texttt{test} is
replaced by \texttt{add} which doesn't chage a register the \texttt{setne}
instruction would check.},
label=lst:nginxex]
    3c935:      48 83 c0 01             add    $0x1,%rax
    3c939:      0f b6 10                movzbl (%rax),%edx
-   3c93c:      84 d2                   test   %dl,%dl
+   3c93c:      04 d2                   add    $0xd2,%al
    3c93e:      0f 95 c1                setne  %cl
    3c941:      80 fa 24                cmp    $0x24,%dl
\end{lstlisting}
\end{minipage}

In Listing~\ref{lst:nginxex}, we show a diff for the \texttt{nginx} binary, the
flip in this example changes a call to \texttt{test} to \texttt{add}. The
instruction afterwards is \texttt{setn}, used to set a byte if the condition,
in this case ``not equal'', is met. As \texttt{add}
does not affect the \texttt{ZF} register, which the \texttt{setn} checks, the
code is likely to behave differently.

Testing the \texttt{nginx} ELF files took a total of about eighteen hours time.
The timing is that high cause we had to make sure the server is up and ready to
reply to our requests for each test. For testing, we have used eight parallel
testing instances.

\section{\texttt{sshd} - Secure Shell Server Login Bypass}

For the \texttt{ssh}-server, our goal is to achieve a login without knowing the
correct password. We configure our test environment with an additional user,
which allows remote logins via password. On a successful connection, the secure
shell \texttt{ssh} should be able to execute commands inside the test
environment.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Instrumentation}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

Instrumenting \texttt{sshd} is very similar to \texttt{nginx}, it is possible to
run the \texttt{ssh}-server without super-user privileges. We instrument only
the code ran during a request, because usually the \texttt{ssh}-daemon is
started during the boot procedure and never exited. We attach Pin to the running
server, try to connect with a correct username but a wrong password, wait for
the denying answer from the server and stop instrumentation.  With this, we
should get exactly the memory accesses necessary used to verify user
credentials.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Testing}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

Verifying the success state is straightforward. We copy the flipped binary,
start the server and wait for some seconds for the startup to complete. To
verify the success state, we try to connect to the remote server with a wrong
password and attempt to execute \texttt{whoami}. As the ssh client does not
allow using pipes to provide a password, we had to use
\texttt{passh}~\cite{passhweb} to send the credentials to the
client\textquotesingle s input. The call of \texttt{whoami} should return the
username from the credentials used to connect. We tested the
\texttt{OpenSSH\_7.4p1 Debian-10+deb9u4} version of the server and client, both
used the OpenSSL version \texttt{1.0.2l}.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Results}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

For the used \texttt{ssh} server we can only report working bitflips in the
loaded libraries. Additional, all of the reported flips were found in the
\texttt{.text} section of the ELF files. Table~\ref{tab:sshdres} gives an
overview of the number of flips found per file. We can see, that most bitflips
can be found in the \texttt{libc} of the host system, also the cryptographic
library and the linker are affected for Rowhammer targeting a \texttt{ssh}
login.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & \texttt{.text} \\ \hline
\texttt{libc.so.6}         & $34$ \\
\texttt{libcrypto.so.1.0.2} & $6$ \\
\texttt{ld-linux-x86-64.so.2} & $1$ \\ \hline
Sum of flips:                 & $41$
\end{tabular}
\caption{List of flips inside the \texttt{sshd(7.4p1)} program
causing a authentication bypass, whereas all of them were in the \texttt{.text}
sections of dynamically loaded libraries.}
\label{tab:sshdres}
\end{table}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to the
\texttt{libcrypto.so.1.0.2} binary in order to bypass a credential check. The
move from \texttt{rbx} to \texttt{rdi} is exchanged with a move to
\texttt{r15}, this changes the parameter for \texttt{EVP\_MD\_CTX\_test\_flags},
which is highly likely to result in a different outcome.},
label=lst:sshdex]
   1341c5:      74 ad                  je     134174 <EVP_MD_CTX_cleanup>
   1341c7:      be 04 00 00 00         mov    $0x4,%esi
-  1341cc:      49 89 df               mov    %rbx,%rdi
+  1341cc:      48 89 df               mov    %rbx,%r15
   1341cf:      e8 dc e5 f3 ff         callq  727b0 <EVP_MD_CTX_test_flags@plt>
   1341d4:      85 c0                  test   %eax,%eax
\end{lstlisting}
\end{minipage}

In Listing~\ref{lst:sshdex}, we show a diff for the \texttt{libcrypto} library
used by \texttt{ssh}. We can see how changing the function parameters
(\texttt{rdi}) for \texttt{EVP\_MD\_CTX\_test\_flags@plt} changes the outcome
of the libary call in a way ssh will think it is working with correct
credentials.

Testing the \texttt{ssh} server took about six hours. The timing here is lower
than for \texttt{nginx} or \texttt{sudo}, as the shell server was faster ready
than \texttt{nginx}, and there were not so many flips to test as in
\texttt{sudo}.

\section{Local Login Bypass on Linux-based Operating Systems}

If attackers have local access to computers and the network, the nethammer
attack~\cite{nethammer} could be used to introduce bitflips to the running
system. An attacker could target the login procedure to gain full access to the
system. On most Linux-based systems local logins are done via the
\texttt{/bin/login} application. This program is called on the default terminal
by the init process, after the bootup of the operating system. The goal is to
find bitflips which would allow logging in without knowing the correct password.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Instrumentation}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

As the \texttt{/bin/login} binary has to be run as root, we use a similar
approach as for \texttt{sudo}. We again make use of the preloaded library from
Listing~\ref{lst:presleeplib}. The instrumentation for \texttt{/bin/login} takes
longer than for the other programs. A reason for this could either be the key
derivation functions used or timeouts build in to prevent brute-forcing the
local login. We start the program and attach to the created process shortly
after, we then try to login with a wrong password and wait for the application
to quit. All accesses during this are logged. To simplify the procedure, we
configure the login to allow just one login try instead of the default five.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Testing}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

\texttt{/bin/login} expects input on a \texttt{TTY}, the Linux terminal
interface, using pipes to redirect the input does not work for testing. To get
around this issue, we use \texttt{passh}~\cite{passhweb}, which is usually used
for automating \texttt{ssh} logins, but it also works for our problem. To find
out if we result in a successful state, we run the login binary as root, send
credentials with a correct username and a wrong password, and check if the
system changed the current user from \texttt{root} to the other user. We tested
the \texttt{/bin/login} binary included in the \texttt{shadow-utils 4.4}.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Results}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

For \texttt{/bin/login}, we can report bitflips in loaded libraries and also the
program\textquotesingle s binary itself. All the found bitflips were in the
\texttt{.text} section of ELF files. As Table~\ref{tab:loginres} shows, there
were $178$ flips ending in a successful bypass of the login service. Most flips
were found in \texttt{pam} libraries, which are a major part of the user
management in Linux-based operating systems.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & \texttt{.text} \\ \hline
\texttt{login}         & $57$ \\
\texttt{pam\_unix.so} & $64$ \\
\texttt{pam\_nologin.so} & $2$ \\
\texttt{pam\_securetty.so} & $5$ \\
\texttt{libpam.so.0} & $50$ \\ \hline
Sum of flips:                 & $178$
\end{tabular}
\caption{List of flips inside the \texttt{login(shadow-utils 4.4)} program
causing a bypass of the local login check.}
\label{tab:loginres}
\end{table}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to the
\texttt{pam\_nologin.so} binary in order to bypass a credential check. The
pop to register $15$ gets exchanged with a pop to register $14$, therefore the
value of \texttt{r15} and \texttt{r14} are not as desired and hence the
execution path of \texttt{/bin/login} changes in a way the login
procedure succeeds.},
label=lst:loginex]
  c37:  41 5d                   pop    %r13
  c39:  41 5e                   pop    %r14
- c3b:  41 5f                   pop    %r15
+ c3b:  41 5e                   pop    %r14
  c3d:  c3                      retq
  c3e:  66 90                   xchg   %ax,%ax
\end{lstlisting}
\end{minipage}

In Listing~\ref{lst:loginex}, we show a diff for the \texttt{pam\_nologin.so}
file after a bitflip was applied at the address \texttt{0x0c3b}. With
the applied flip, register values get changed as the value which should be
written to register $15$ is placed in register $14$ instead, overwriting the
value placed there before.

Testing \texttt{/bin/login} tool about 35 hours. This is mainly due to the long
response time by the program itself, which is probably a countermeasure against
local brute-forcing. Also, there were by far the most memory accesses reported
by the instrumentation pintool.

\section{Summery of the Results}

In summary, we can show, that all our tested programs can be exploited by
bitflips. We show that Rowhammer can be used for privilege escalation and
security bypasses in common applications used in most Linux-based operating
systems. We can report that most bitflips can be found in the \texttt{.text}
section of ELF files, which contains the executed machine code. Also, we show
that not only binaries on its own are suffering such flaws, but also loaded
libraries introduce exploitable bitflips to programs. The diffs of the
disassembly show, that when flipping code, not only the opcode can be abused but
also parameters in instructions.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & Shared flips \\ \hline
\texttt{pam\_unix.so} & $52$ \\
\texttt{libpam.so.0} & $18$ \\ \hline
Sum of flips:                 & $70$
\end{tabular}
\caption{Number of flips which work for a login bypass and a \text{sudo}
privilege escalation.}
\label{tab:loginsudo}
\end{table}

Besides that, we can report that some bitflips cause a bypass in multiple
application. For example most \texttt{pam} related flips can be abused in the
\texttt{login} program and \texttt{sudo} as both check against the same user
management. An attacker, therefore, could introduce a flip in the
\texttt{libpam.so.0} file, log in as the user and gain super-user access if the
user is allowed to use \texttt{sudo}. Table~\ref{tab:loginsudo} show the exact
number of shared bitflips between the two applications. Also, for \texttt{sudo}
and \texttt{sshd}, there was one shared bitflip found, namely one in the
\texttt{ld-linux-x86-64.so.2} file at address \texttt{0xfc6c}.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
