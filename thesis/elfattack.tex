%%%%%% Static Data Flips %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Bitflip Attacks on ELF Files}\label{sec:bitflip}

In this chapter, we will discuss our approach to automate the finding bitflips
in ELF files to gain privilege escalation. This is an approach which
Gruss~\etal~\cite{flipinthewall} already have shown by disassembling binaries
and manually looking for them. We start by describing the impact of a single
bitflip. Then, we look at our work and the framework we created to find bitflips
in binaries to change their behaviour to a pre-defined state. We take a look at
the framework design in general. Then we look at the details on how we find bits
to check, how the definition for searching works, how we test the bitflips and
how results are captured and verified.

\section{Changing the Execution Path with a Single Bitflip}

The task of our thesis was to find a bit in an ELF file which we can flip to
change the behaviour in a way that it benefits us. See the code in
listing~\ref{lst:csimbranch} for example. We want to change the binary in a way
it will print \texttt{success.} instead of \texttt{fail.}, and all this by just
toggling a single bit. For this, we look at the disassembly of the code in
listing~\ref{lst:disasmsimplebranch}. From this, we first mention that we can
change the \texttt{1} can to a \texttt{0} at the \texttt{mov} instruction on
address \texttt{0x0642}. Besides that, also the opcode of \texttt{jnz}, namely
\texttt{0x75 (1110101)}, can be changed into a \texttt{jz}, as this is
\texttt{0x74 (1110100)}, at address \texttt{0x064d}. For compiling we
used~\texttt{gcc (Ubuntu 7.3.0-16ubuntu3) 7.3.0}~\cite{gccubuntu}, for
disassembling~\texttt{radare2 2.3.0-git 17214}~\cite{radare2web}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Simple branching code to show an example for a
single bitflip to change the execution path.},
                   label={lst:csimbranch}]
#include <stdio.h>
int main(void)
{
  int x = 0;
  if(x == 1)
    printf("success.\n");
  else
    printf("fail.\n");
  return 0;
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=nasm,
                   caption={Disassemby of the main function created by the
code in listing~\ref{lst:csimbranch}. Shows machine code at given address
inside the ELF file, starting at \texttt{0x063a}.},
                   label={lst:disasmsimplebranch}]
0x063a  push rbp
0x063b  mov rbp, rsp
0x063e  sub rsp, 0x10
0x0642  mov dword [local_4h], 0
0x0649  cmp dword [local_4h], 1  ; [0x1:4]=0x2464c45
0x064d  jnz 0x65d
0x064f  lea rdi, str.success.    ; 0x6f4 ; "success."
0x0656  call sym.imp.puts        ; int puts(const char *s)
0x065b  jmp 0x669
0x065d  lea rdi, str.fail.       ; 0x6fd ; "fail."
0x0664  call sym.imp.puts        ; int puts(const char *s)
0x0669  mov eax, 0
0x066e  leave
0x066f  ret
\end{lstlisting}
\end{minipage}

To line out what other possible changes could be done when changing the
\texttt{jnz}, we flip each bit in the \texttt{0x75}-byte and look at the output
of the resulting binary. The flips and results are pointed out in
table~\ref{tab:jnzflips}. We see that in three cases the program would print
\texttt{success.}, in one case the output would not change and in four cases the
program would crash for different reasons.

\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
Opcode & Hex Value & Describtion                                           &
Output              \\ \hline
JZ     & 0x74      & Jump short if zero/equal                              &
success.            \\ \hline
JNBE   & 0x77      & Jump short if not below or equal/above                &
success.            \\ \hline
JNO    & 0x71      & Jump short if not overflow                            &
fail.               \\ \hline
JNL    & 0x7D      & Jump short if less or equal/not greater               &
success.            \\ \hline
GS     & 0x65      & GS segment override prefix                            &
Illegal instruction \\ \hline
PUSH   & 0x55      & ($50+r$) Push onto the Stack &
Illegal instruction \\ \hline
XOR    & 0x35      & Logical Exclusive OR                                  &
Segmentation fault  \\ \hline
CMC    & 0xF5      & Complement Carry Flag                                 &
Illegal instruction \\ \hline
\end{tabular}
\caption{Possible opcodes resulting from changing a single bit in
\texttt{JNZ}~\texttt{0x75} and the output when applied in the assembly showed in
listing~\ref{lst:disasmsimplebranch}.}
\label{tab:jnzflips}
\end{table}

From this, we gain the knowledge that at least three bitflips to the opcode give
us our desired behaviour. Additionally, we can add the bitflip to the $1$, which
makes it four, which we can find manually quite fast. Now, the question arises
how do we automate this searching process?

\section{Automating the Finding of Feasible Bitflips}

Testing all possible bitflips inside the binary and report each output would be
a way to gain all of those which would result in the printing of
\texttt{success.}. The binary resulting from the compilation of the small
branching code from listing~\ref{lst:csimbranch} has a size of $8288$ bytes,
which means there are $66304$ bitflips to test. With an execution time of
$0,003$ seconds per run, this means that it would take close to $200$ seconds to
test all bits inside the binary. For our automation, we want a drastically lower
number.

\subsection{Design of the Testing Framework}

We implemented a framework to search bits to flip in binaries.
Figure~\ref{fig:frameworkdesign} shows a diagram describing the framework. The
framework is split into multiple parts:

\begin{enumerate}
\item We log the accessed memory areas from all the ELF files the binary uses.
\item We apply pre-defined filters to the results.
\item We generate ELF files for each of the bit flips
\item We execute each ELF file and check if the output fits a pre-defined
success state
\end{enumerate}

\begin{figure}
  \centering
  \begin{tikzpicture}
  % Nodes of the framework
  \node (start) [root] {Start};
  \node (conf) [function, right of=start, xshift=2cm] {Load config};
  \node (instr) [function, right of=conf, align=center, xshift=2cm]
                {Instrument \\ binary};
  \node (filter) [function, right of=instr, align=center, xshift=2cm]
                 {Filter \\ memory areas};
  \node (gen) [function, below of=filter, align=center, yshift=-1cm]
              {Generate \\ flipped binaries};
  \node (test) [function, below of=gen, align=center, yshift=-1cm]
               {Test \\ generated files};
  \node (report) [function, below of=test, align=center, yshift=-1cm]
                 {Log results};
  \node (clean) [function, right of=report, align=center, xshift=2cm]
                {Delete \\ generated files};
  \node (dec) [decision, below of=report, align=center, yshift=-1cm]
              {Finished?};
  \node (propclean) [function, left of=dec, align=center, xshift=-2cm]
                    {Cleanup \\ Testing \\ Environment};
  \node (printres) [function, left of=propclean, align=center, xshift=-2cm]
                   {Print Results};
  \node (finish) [finish, left of=printres, xshift=-2cm] {Done};
  % Connections
  \draw [arrow] (start) -- (conf);
  \draw [arrow] (conf) -- (instr);
  \draw [arrow] (instr) -- (filter);
  \draw [arrow] (filter) -- (gen);
  \draw [arrow] (gen) -- (test);
  \draw [arrow] (test) -- (report);
  \draw [arrow] (report) -- (dec);
  \draw [arrow] (dec) -- (propclean) node[near start, above] {Yes};
  \draw [arrow] (propclean) -- (printres);
  \draw [arrow] (printres) -- (finish);
  \draw [arrow] (dec) -| (clean) node[near start, above] {No};
  \draw [arrow] (clean) |- (gen);
  \end{tikzpicture}
  \caption{Flowchart showing each part of the framework and their connections.}
  \label{fig:frameworkdesign}
\end{figure}

Each part of the framework is designed to work on its own and has a clearly
defined input and output. The parts can quickly be adopted or used for other
testing purposes. The configuration file for the framework defines how each step
is applied to the program as instrumentation and verification differ for each
application. The file in listing~\ref{lst:expconfig} shows an example config
file for the framework. Figure~\ref{fig:framfilesys} shows the layout of the
framework in the file system. The configuration file tells the framework where
to find each of the needed files. The template chroot describes the system used
for testing.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=nasm,
                   caption={JSON style config file for the framework, showing
all parameters used to tweak each part of the framework. Entries
starting with \texttt{CR\_} are used inside the testing \texttt{chroot}.},
                   label={lst:expconfig}]
{
  "instrumenter_call": "./instr_tool.sh",
  "instrumenter_outfile": "tool.out",
  "chroot_template": "chroot_tmpl/bionic",
  "tmp_chroot_folder": "/media/ramdisk/chroot/",
  "folder_with_flips": "/media/ramdisk/flips/",
  "num_of_parallel_checks": 1,
  "CR_exec_file": "./run_tool_chroot.sh",
  "CR_flip_folder": "/media/flips",
  "CR_success_folder": "/media/success/",
  "CR_log_file": "/tmp/succ.file"
}
\end{lstlisting}
\end{minipage}

\begin{figure}
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node [fsnode] {proj.root}
    child {node[fsnode] {tool\_config.json}}
    child {node [fsnode] {instr\_tool.sh}}
    child {node [fsnode] {run\_tool\_chroot.sh}}
    child {node [fsnode, optional] {tool.out}}
    child {node [fsnode] {chroot\_tmpl/}
      child {node [fsnode] {bionic/}}
      };
  \node [fsnode, xshift=5cm] {chroot.root}
    child {node [fsnode] {media/}
      child {node [fsnode] {success/}}
      child {node [fsnode] {flips/}}
    }
    child [missing] {}
    child [missing] {}
    child {node [fsnode] {tmp/}
      child {node [fsnode] {succ.file}}
    }
    child [missing] {}
    child {node [fsnode, optional] {run\_tool\_chroot.sh}};
\end{tikzpicture}
\caption{File system structure of framework and the chroot loaded for the test
runs, whereas the chroot is created from a templated loaded from the
\texttt{proj.root} and the \texttt{run\_tool\_chroot.sh} is copied over to the
created chroot.}
\label{fig:framfilesys}
\end{figure}

\subsubsection{Instrumenting the Program}

We use Intel Pin~\cite{pintool} for instrumentation. The instrumentation is used
to log every memory access during execution of the program, whereas we want to
log all accesses which happen inside of ELF files, which means the program's
binary and all libraries used by it during runtime. The used pintool is the same
for all test runs. It adds instrumenter calls to all memory accesses. The tools
stores all accesses per file and what base offsets are used. This information is
needed to determine if the accessed area is mapped to a file later on.

We instrument the program with a run defining a failed state, after the run, we
filter the accessed memory areas for each file and check if areas were written
before reading. If so, we can also skip testing those bits, as the program would
overwrite the flips again. Listing~\ref{lst:pinlogcode} shows an example code
snippet of a pintool which logs all memory accesses as it instruments each
instruction and logs the opcode position and its parameters if they address
memory. The listing~\ref{lst:pinlogcode} also shows some API-calls for the PIN
framework. In Pin, the Image~\texttt{img} refers to files. These are most of the
time dynamically loaded libraries. The \texttt{INS\_InsertPredicatedCall}
function is used to insert a function call on the machine code layer. The
function can have an arbitrary number of parameters, as the user have to define
the function with each parameter and the type. Pin then inserts a call to the
given function pointer and manages the handling of the parameters and return
values in a way that the instrumented binary's execution is not affected.

Instrumentation is done via the configured \texttt{instrumenter\_call}. That
entry is executed and expected to generate a file named in the
\texttt{instrumenter\_outfile} configuration parameter. This file needs to
follow an output format for the accesses as in \texttt{<hex:position\_in\_file>
- str:filename}. The framework then applies a filter to that before it tests the
actual bitflips.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Example C++ code for a pintool logging memory
accesses. At first, the tool stores the instruction bytes, and after the
operands are stored separately, depending on if they are writing or reading
memory.},
                   label={lst:pinlogcode}]
ADDRINT ins_addr = INS_Address(ins);
IMG img = IMG_FindByAddress(ins_addr);
ADDRINT base = IMG_LowAddress(img);
img_offsets[base] = IMG_LoadOffset(img);

for(size_t i = 0; i < INS_Size(ins); i++)
  accesses.insert(std::make_pair(ins_addr + i, base));

UINT32 memOperands = INS_MemoryOperandCount(ins);
for (UINT32 memOp = 0; memOp < memOperands; memOp++)
{
  if(INS_MemoryOperandIsRead(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,
      IARG_INST_PTR,
      IARG_MEMORYREAD_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYREAD_SIZE,
      IARG_END);
  }
  if(INS_MemoryOperandIsWritten(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,
      IARG_INST_PTR,
      IARG_MEMORYWRITE_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYWRITE_SIZE,
      IARG_END);
  }
}
\end{lstlisting}
\end{minipage}

\subsubsection{Filtering Memory Accesses reported by the Instrumentation}

We apply a filter to the memory accesses at two different points. At first, we
already filter inside the written pintool. As we log reading and writing
accesses to memory separately, we can check on reading accesses if the program
has written to the position before, if so, there is no need to flip this
location in the binary.

At second, after the program run, we translate all reported accessed addresses
to positions in ELF files. At this point, every access which does not refer to
the file content is thrown away. We can find this as we know the base address
from the loaded library from the pintool report.

Additionally, we add addresses of ELF structure headers, as remapping sections
or change other property bits inside the ELF structure can affect the way the
binary runs. After applying the filters, we gain a list of bytes to flip.

\subsubsection{Generating and Testing the Flips}

Next, we create a new ELF file for each bit for each of the reported bytes. We
generate those files into a \texttt{tmpfs} file-system placing its memory in the
DRAM to have lower access times than to the hard drive. Depending on the
configured number of parallel checks, chroots are created in the \texttt{tmpfs}
too. The framework makes sure the number of created ELF files does not need more
than the memory available. If there are more files to test than the available
memory allows, the framework takes multiple runs, as seen in
figure~\ref{fig:frameworkdesign}. A test run starts configured
\texttt{CR\_exec\_file} which will copy a flipped file from
\texttt{CR\_flip\_folder} to the original position, then run it and check if the
output matches a defined success state. If the flipped file reaches the success
state, the framework writes the flipped address to \texttt{CR\_log\_file} and
copies the flipped ELF file to \texttt{CR\_success\_folder}.

\subsection{Applying the Framework to real-world Applications}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsubsection{\texttt{sudo} - Privilege Escalation}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\paragraph{Instrumentation} Lorem ipsum dolor sit amet, consetetur sadipscing
elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores
et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.

\paragraph{Testing} Lorem ipsum dolor sit amet, consetetur sadipscing
elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores
et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.

\subsubsection{\texttt{nginx} - Basic Authentication}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\paragraph{Instrumentation} Lorem ipsum dolor sit amet, consetetur sadipscing
elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores
et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.

\paragraph{Testing} Lorem ipsum dolor sit amet, consetetur sadipscing
elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores
et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.

\subsection{Results given by the Framework}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsubsection{\texttt{sudo} - Privilege Escalation}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsubsection{\texttt{nginx} - Basic Authentication}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
