%%%%%% Static Data Flips %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Bitflip Attacks on ELF Files}\label{sec:bitflip}

In this chapter, we will discuss our approach to automate the finding bitflips
in ELF files to gain privilege escalation. This is an approach which
Gruss~\etal~\cite{flipinthewall} already have shown by disassembling binaries
and manually looking for them. We start by describing the impact of a single
bitflip. Then, we look at our work and the framework we created to find bitflips
in binaries to change their behaviour to a pre-defined state. We take a look at
the framework design in general. Then we look at the details on how we find bits
to check, how the definition for searching works, how we test the bitflips and
how results are captured and verified.

\section{Changing the Execution Path with a Single Bitflip}

The task of our thesis was to find a bit in an ELF file which we can flip to
change the behaviour in a way that it benefits us. See the code in
listing~\ref{lst:csimbranch} for example. We want to change the binary in a way
it will print \texttt{success.} instead of \texttt{fail.}, and all this by just
toggling a single bit. For this, we look at the disassembly of the code in
listing~\ref{lst:disasmsimplebranch}. From this, we first mention that we can
change the \texttt{1} can to a \texttt{0} at the \texttt{mov} instruction on
address \texttt{0x0642}. Besides that, also the opcode of \texttt{jnz}, namely
\texttt{0x75 (1110101)}, can be changed into a \texttt{jz}, as this is
\texttt{0x74 (1110100)}, at address \texttt{0x064d}. For compiling we
used~\texttt{gcc (Ubuntu 7.3.0-16ubuntu3) 7.3.0}~\cite{gccubuntu}, for
disassembling~\texttt{radare2 2.3.0-git 17214}~\cite{radare2web}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Simple branching code to show an example for a
single bitflip to change the execution path.},
                   label={lst:csimbranch}]
#include <stdio.h>
int main(void)
{
  int x = 0;
  if(x == 1)
    printf("success.\n");
  else
    printf("fail.\n");
  return 0;
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=nasm,
                   caption={Disassemby of the main function created by the
code in listing~\ref{lst:csimbranch}. Shows machine code at given address
inside the ELF file, starting at \texttt{0x063a}.},
                   label={lst:disasmsimplebranch}]
0x063a  push rbp
0x063b  mov rbp, rsp
0x063e  sub rsp, 0x10
0x0642  mov dword [local_4h], 0
0x0649  cmp dword [local_4h], 1  ; [0x1:4]=0x2464c45
0x064d  jnz 0x65d
0x064f  lea rdi, str.success.    ; 0x6f4 ; "success."
0x0656  call sym.imp.puts        ; int puts(const char *s)
0x065b  jmp 0x669
0x065d  lea rdi, str.fail.       ; 0x6fd ; "fail."
0x0664  call sym.imp.puts        ; int puts(const char *s)
0x0669  mov eax, 0
0x066e  leave
0x066f  ret
\end{lstlisting}
\end{minipage}

To line out what other possible changes could be done when changing the
\texttt{jnz}, we flip each bit in the \texttt{0x75}-byte and look at the output
of the resulting binary. The flips and results are pointed out in
table~\ref{tab:jnzflips}. We see that in three cases the program would print
\texttt{success.}, in one case the output would not change and in four cases the
program would crash for different reasons.

\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
Opcode & Hex Value & Describtion                                           &
Output              \\ \hline
JZ     & 0x74      & Jump short if zero/equal                              &
success.            \\ \hline
JNBE   & 0x77      & Jump short if not below or equal/above                &
success.            \\ \hline
JNO    & 0x71      & Jump short if not overflow                            &
fail.               \\ \hline
JNL    & 0x7D      & Jump short if less or equal/not greater               &
success.            \\ \hline
GS     & 0x65      & GS segment override prefix                            &
Illegal instruction \\ \hline
PUSH   & 0x55      & ($50+r$) Push onto the Stack &
Illegal instruction \\ \hline
XOR    & 0x35      & Logical Exclusive OR                                  &
Segmentation fault  \\ \hline
CMC    & 0xF5      & Complement Carry Flag                                 &
Illegal instruction \\ \hline
\end{tabular}
\caption{Possible opcodes resulting from changing a single bit in
\texttt{JNZ}~\texttt{0x75} and the output when applied in the assembly showed in
listing~\ref{lst:disasmsimplebranch}.}
\label{tab:jnzflips}
\end{table}

From this, we gain the knowledge that at least three bitflips to the opcode give
us our desired behaviour. Additionally, we can add the bitflip to the $1$, which
makes it four, which we can find manually quite fast. Now, the question arises
how do we automate this searching process?

\section{Automating the Finding of Feasible Bitflips}

Testing all possible bitflips inside the binary and report each output would be
a way to gain all of those which would result in the printing of
\texttt{success.}. The binary resulting from the compilation of the small
branching code from listing~\ref{lst:csimbranch} has a size of $8288$ bytes,
which means there are $66304$ bitflips to test. With an execution time of
$0,003$ seconds per run, this means that it would take close to $200$ seconds to
test all bits inside the binary. For our automation, we want a drastically lower
number.

\subsection{Design of the Testing Framework}

We implemented a framework to search bits to flip in binaries.
Figure~\ref{fig:frameworkdesign} shows a diagram describing the framework. The
framework is split into multiple parts:

\begin{enumerate}
\item We log the accessed memory areas from all the ELF files the binary uses.
\item We apply pre-defined filters to the results.
\item We generate ELF files for each of the bit flips
\item We execute each ELF file and check if the output fits a pre-defined
success state
\end{enumerate}

\begin{figure}
  \centering
  \begin{tikzpicture}
  % Nodes of the framework
  \node (start) [root] {Start};
  \node (conf) [function, right of=start, xshift=2cm] {Load config};
  \node (instr) [function, right of=conf, align=center, xshift=2cm]
                {Instrument \\ binary};
  \node (filter) [function, right of=instr, align=center, xshift=2cm]
                 {Filter \\ memory areas};
  \node (gen) [function, below of=filter, align=center, yshift=-1cm]
              {Generate \\ flipped binaries};
  \node (test) [function, below of=gen, align=center, yshift=-1cm]
               {Test \\ generated files};
  \node (report) [function, below of=test, align=center, yshift=-1cm]
                 {Log results};
  \node (clean) [function, right of=report, align=center, xshift=2cm]
                {Delete \\ generated files};
  \node (dec) [decision, below of=report, align=center, yshift=-1cm]
              {Finished?};
  \node (propclean) [function, left of=dec, align=center, xshift=-2cm]
                    {Cleanup \\ Testing \\ Environment};
  \node (printres) [function, left of=propclean, align=center, xshift=-2cm]
                   {Print Results};
  \node (finish) [finish, left of=printres, xshift=-2cm] {Done};
  % Connections
  \draw [arrow] (start) -- (conf);
  \draw [arrow] (conf) -- (instr);
  \draw [arrow] (instr) -- (filter);
  \draw [arrow] (filter) -- (gen);
  \draw [arrow] (gen) -- (test);
  \draw [arrow] (test) -- (report);
  \draw [arrow] (report) -- (dec);
  \draw [arrow] (dec) -- (propclean) node[near start, above] {Yes};
  \draw [arrow] (propclean) -- (printres);
  \draw [arrow] (printres) -- (finish);
  \draw [arrow] (dec) -| (clean) node[near start, above] {No};
  \draw [arrow] (clean) |- (gen);
  \end{tikzpicture}
  \caption{Flowchart showing each part of the framework and their connections.}
  \label{fig:frameworkdesign}
\end{figure}

Each part of the framework is designed to work on its own and has a clearly
defined input and output. The parts can quickly be adopted or used for other
testing purposes. The configuration file for the framework defines how each step
is applied to the program as instrumentation and verification differ for each
application.

\subsubsection{Instrumenting the Program}

We use Intel Pin~\cite{pintool} for instrumentation. The instrumentation is used
to log every memory access during execution of the program, whereas we want to
log all accesses which happen inside of ELF files, which means the program's
binary and all libraries used by it during runtime. The used pintool is the same
for all test runs. It adds instrumenter calls to all memory accesses. The tools
stores all accesses per file and what base offsets are used. This information is
needed to determine if the accessed area is mapped to a file later on.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Example C++ code for a pintool logging memory
accesses. At first, the tool stores the instruction bytes, and after the
operands are stored separately, depending on if they are writing or reading
memory.},
                   label={lst:pinlogcode}]
ADDRINT ins_addr = INS_Address(ins);
IMG img = IMG_FindByAddress(ins_addr);
ADDRINT base = IMG_LowAddress(img);
img_offsets[base] = IMG_LoadOffset(img);

for(size_t i = 0; i < INS_Size(ins); i++)
  accesses.insert(std::make_pair(ins_addr + i, base));

UINT32 memOperands = INS_MemoryOperandCount(ins);
for (UINT32 memOp = 0; memOp < memOperands; memOp++)
{
  if(INS_MemoryOperandIsRead(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,
      IARG_INST_PTR,
      IARG_MEMORYREAD_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYREAD_SIZE,
      IARG_END);
  }
  if(INS_MemoryOperandIsWritten(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,
      IARG_INST_PTR,
      IARG_MEMORYWRITE_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYWRITE_SIZE,
      IARG_END);
  }
}
\end{lstlisting}
\end{minipage}

We instrument the program with a run defining a failed state, after the run, we
filter the accessed memory areas for each file and check if areas were written
before reading. If so, we can also skip testing those bits, as the program would
overwrite the flips again. Listing~\ref{lst:pinlogcode} shows an example code
snippet of a pintool which logs all memory accesses as it instruments each
instruction and logs the opcode position and its parameters if they address
memory.

\subsubsection{Finding Successful Flips}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsubsection{Testing all Flips}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsection{Applying the Framework to real-world Applications}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsubsection{\texttt{sudo} - Privilege Escalation}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\paragraph{Instrumentation} Lorem ipsum dolor sit amet, consetetur sadipscing
elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores
et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.

\paragraph{Testing} Lorem ipsum dolor sit amet, consetetur sadipscing
elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores
et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.

\subsubsection{\texttt{nginx} - Basic Authentication}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\paragraph{Instrumentation} Lorem ipsum dolor sit amet, consetetur sadipscing
elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores
et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.

\paragraph{Testing} Lorem ipsum dolor sit amet, consetetur sadipscing
elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores
et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.

\subsection{Results given by the Framework}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsubsection{\texttt{sudo} - Privilege Escalation}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

\subsubsection{\texttt{nginx} - Basic Authentication}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
