%%%%%% Static Data Flips %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Bitflip Attacks on ELF Files}\label{sec:elfattack}

In this chapter, we present a novel to automate finding bitflips in ELF which
yield exploitable execution path changes. Gruss~\etal~\cite{flipinthewall}
already have shown a similar approach by disassembling binaries and manually
looking for exploitable bitflips. We start by discussing their approach and
point out the downsides of the manual search.

Then we describe our task and the framework we created to find exploitable
bitflips in binaries to change their behaviour to a pre-defined state. We start
with a general overview of the framework design and go on with discussing the
details on how we find bits to check, how the definition for searching works,
how we test the bitflips and how results are captured and verified.

\section{Analysing the Manual Search Approach}

Gruss~\etal~\cite{flipinthewall} introduce so-called opcode flipping to bypass
the Rowhammer countermeasure of physical kernel memory isolation, which was
proposed as a countermeasure to prevent bitflips in page tables. With opcode
flipping, it is possible to gain privilege escalation by flipping pages which
hold executable code. Gruss~\etal~\cite{flipinthewall} describe their approach
as follows. First, a memory area in the binary is defined, which holds bits to
test with flipping. Secondly, all bits in the defined area are flipped,
resulting binaries are executed, and grouped by the outcoming results. In the
end, the results are analysed manually, and exploitable behaviours are noted and
then attacked with Rowhammer. Gruss~\etal~\cite{flipinthewall} show a case study
of this approach where the \texttt{sudo} program is analysed and report \SI{29}
bitflips which give an attacker root permissions without knowing the
user\textquotesingle s password.

As this approach seems feasible, we claim that it is not practical.
Gruss~\etal~\cite{flipinthewall} analysed the program\textquotesingle s binary,
and the dynamically loaded libraries to identify targetable memory areas, by
this choice, areas might be missed. Also, each bit in a defined area is tested,
which could include bits of memory which is never executed during the
program\textquotesingle s run. Manually analysing the results may take much time
and might not be feasible for a larger number of bitflips. Besides flipping
opcodes, also prefixes and parameters of instructions should be tested for
bitflips. Also, not only specific memory areas holding executable code should be
tested but all memory in binaries accessed during the runtime of the program. As
Gruss~\etal~\cite{flipinthewall} only check a specific version of a program,
the reported bitflips might not work in a newer version, and the same work has
to be done again.

\section{Automating the Finding of Feasible Bitflips}

Flipping all bits inside a binary, reporting each output and check for a
successful outcome might be a way to generate a list of all exploitable
bitflips. Looking at the compiled binary from Listing~\ref{lst:csimbranch}, in
Section~\ref{sec:motivation}, it would result in a \SI{8288}{\byte} file.
Following the approach of testing all possible bits, would result in \SI{66304}
bitflips to test. With an execution time of approximately \SI{0.003}{\second}, a
complete test run would take close to \SI{200}{\second}.

Looking at \texttt{sudo}, the ELF file of the program alone has
\SI{149080}{\byte}, without dynamic libraries, and the execution time is around
\SI{0.03}{\second}. The same approach applied to \texttt{sudo} would, therefore,
take around \SI{35780}{\second}, which is approximately \SI{10}{\hour}. Such a
long time is not feasible, as dynamic libraries used also need to be tested.
Including those libraries, would result in \SI{3219208}{\byte}, which would
require approximately \SI{215}{\hour} or \SI{9} days.

Four our automation of the exploitable bitflip search, we want to require way
less time than with the test all bit approach, as we want to target larger
real-world applications.

\subsection{Design of the Testing Framework}

\begin{figure}
  \centering
  \begin{tikzpicture}
  % Nodes of the framework
  \node (start) [root] {Start};
  \node (conf) [function, right of=start, xshift=2cm] {Load config};
  \node (instr) [function, right of=conf, align=center, xshift=2cm]
                {Instrument \\ binary};
  \node (filter) [function, right of=instr, align=center, xshift=2cm]
                 {Filter \\ memory areas};
  \node (gen) [function, below of=filter, align=center, yshift=-1cm]
              {Generate \\ flipped binaries};
  \node (test) [function, below of=gen, align=center, yshift=-1cm]
               {Test \\ generated files};
  \node (report) [function, below of=test, align=center, yshift=-1cm]
                 {Log results};
  \node (clean) [function, right of=report, align=center, xshift=2cm]
                {Delete \\ generated files};
  \node (dec) [decision, below of=report, align=center, yshift=-1cm]
              {Finished?};
  \node (propclean) [function, left of=dec, align=center, xshift=-2cm]
                    {Cleanup \\ Testing \\ Environment};
  \node (printres) [function, left of=propclean, align=center, xshift=-2cm]
                   {Print Results};
  \node (finish) [finish, left of=printres, xshift=-2cm] {Done};
  % Connections
  \draw [arrow] (start) -- (conf);
  \draw [arrow] (conf) -- (instr);
  \draw [arrow] (instr) -- (filter);
  \draw [arrow] (filter) -- (gen);
  \draw [arrow] (gen) -- (test);
  \draw [arrow] (test) -- (report);
  \draw [arrow] (report) -- (dec);
  \draw [arrow] (dec) -- (propclean) node[near start, above] {Yes};
  \draw [arrow] (propclean) -- (printres);
  \draw [arrow] (printres) -- (finish);
  \draw [arrow] (dec) -| (clean) node[near start, above] {No};
  \draw [arrow] (clean) |- (gen);
  \end{tikzpicture}
  \caption{Flowchart showing each part of the framework and their connections.}
  \label{fig:frameworkdesign}
\end{figure}

We have implemented a framework to search for exploitable bitflips in programs.
Figure~\ref{fig:frameworkdesign} shows a diagram describing the
framework\textquotesingle s design. We split it into multiple parts:

\begin{enumerate}
\begin{samepage}
  \item Accessed memory areas are logged from all the ELF files the program
uses.
  \item Pre-defined filters are applied to the reported memory areas.
  \item ELF files for each of the bit flips are generated.
  \item Each ELF file gets executed, and the behaviour is checked against a
pre-defined success state
\end{samepage}
\end{enumerate}

\begin{figure}
\centering
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node [fsnode] {proj.root}
    child {node[fsnode] {tool\_config.json}}
    child {node [fsnode] {instr\_tool.sh}}
    child {node [fsnode] {run\_tool\_chroot.sh}}
    child {node [fsnode, optional] {tool.out}}
    child {node [fsnode] {chroot\_tmpl/}
      child {node [fsnode] {bionic/}}
      };
  \node [fsnode, xshift=5cm] {chroot.root}
    child {node [fsnode] {media/}
      child {node [fsnode] {success/}}
      child {node [fsnode] {flips/}}
    }
    child [missing] {}
    child [missing] {}
    child {node [fsnode] {tmp/}
      child {node [fsnode] {succ.file}}
    }
    child [missing] {}
    child {node [fsnode, optional] {run\_tool\_chroot.sh}};
\end{tikzpicture}
\caption{File system structure of the framework and the chroot loaded for the
test runs, whereas the chroot is created from a templated loaded from the
\texttt{proj.root} and the \texttt{run\_tool\_chroot.sh} is copied over to the
created chroot.}
\label{fig:framfilesys}
\end{figure}

Each part of the framework is designed to work on its own and has a clearly
defined in- and output-interface. The parts can be adopted or easily used for
other testing purposes. The configuration file for the framework defines how
each step is applied to the application, as instrumentation and verification may
differ for each program. The file in Listing~\ref{lst:expconfig} shows an
example configuration file for the framework. Figure~\ref{fig:framfilesys} shows
the layout of the framework in the file system. The configuration file tells the
framework where to find each of the required files. The template chroot
describes the system used for testing.

\begin{figure}
\begin{minipage}{\linewidth}
\begin{lstlisting}[style=nasm,
                   caption={JSON style config file for the framework, showing
all parameters used to tweak each part of the framework. Entries
starting with \texttt{CR\_} are used inside the testing \texttt{chroot}.},
                   label={lst:expconfig}]
{
  "instrumenter_call": "./instr_tool.sh",
  "instrumenter_outfile": "tool.out",
  "chroot_template": "chroot_tmpl/bionic",
  "tmp_chroot_folder": "/media/ramdisk/chroot/",
  "folder_with_flips": "/media/ramdisk/flips/",
  "num_of_parallel_checks": 1,
  "CR_exec_file": "./run_tool_chroot.sh",
  "CR_flip_folder": "/media/flips",
  "CR_success_folder": "/media/success/",
  "CR_log_file": "/tmp/succ.file"
}
\end{lstlisting}
\end{minipage}
\end{figure}

The framework starts with executing \texttt{instr\_tool.sh} to generate a report
showing all bitflips to test. Additionally, it can also filter them. After the
script\textquotesingle s execution, the \texttt{tool.out}-file contains a list
of all byte positions to flip and test. Afterwards, the defined number of
chroots are created by copying the template from \texttt{chroot\_tmpl}. The
flipped binaries are copied to each \texttt{/media/flips} folder in the testing
chroot. The \texttt{run\_tool\_chroot.sh} file is copied to each testing
environment and executed there. This script runs in each of the \texttt{chroot},
replaces the original binary with a flipped version, runs the configured program
and checks it\textquotesingle s outcome. If the outcome matches a pre-defined
success state, the flipped binary is stored and reported by the framework after
all test runs are finished.

\subsubsection{Instrumenting the Program}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Example C++ code for a pintool logging memory
accesses. The tool stores the locations of instructions and parameters if they
point to memory. The tool stores accesses for reading and writing seperately.},
                   label={lst:pinlogcode}]
ADDRINT ins_addr = INS_Address(ins);
IMG img = IMG_FindByAddress(ins_addr);
ADDRINT base = IMG_LowAddress(img);
img_offsets[base] = IMG_LoadOffset(img);

for(size_t i = 0; i < INS_Size(ins); i++)
  accesses.insert(std::make_pair(ins_addr + i, base));

UINT32 memOperands = INS_MemoryOperandCount(ins);
for (UINT32 memOp = 0; memOp < memOperands; memOp++)
{
  if(INS_MemoryOperandIsRead(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,
      IARG_INST_PTR,
      IARG_MEMORYREAD_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYREAD_SIZE,
      IARG_END);
  }
  if(INS_MemoryOperandIsWritten(ins, memOp))
  {
    INS_InsertPredicatedCall(
      ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,
      IARG_INST_PTR,
      IARG_MEMORYWRITE_EA,
      IARG_ADDRINT, base,
      IARG_MEMORYWRITE_SIZE,
      IARG_END);
  }
}
\end{lstlisting}
\end{minipage}
\end{figure}

We use Intel Pin~\cite{pintool} for instrumentation. We log every memory access
during execution of the program. We want to log all accesses which happen inside
of ELF files, which means the program\textquotesingle s binary and all libraries
it uses during runtime. The pintool we use to achieve this, adds instrumenter
calls to all memory accesses. The tool then logs all accesses per binary and the
offsets of the address in the corresponding ELF file. This information is
required to determine which accessed area is mapped to which file later on.

Listing~\ref{lst:pinlogcode} shows a code snippet of the used pintool which
logs all memory accesses as it instruments each instruction and logs the opcode
position and its parameters if they address memory. For Pin, the
image~\texttt{img} refers to an ELF file stored on the hard drive, the images
represent the program\textquotesingle executable and the dynamic libraries
loaded during execution. The \texttt{INS\_InsertPredicatedCall} function is used
to insert a function call on the machine code layer. The function can have an
arbitrary number of parameters, as the user has to define the function with each
parameter and type. Pin then inserts a call to the given function pointer and
manages the handling of the parameters and return values in a way that the
instrumented program\textquotesingle s execution is not affected.

We instrument the program with a run resulting in a failed state, after the run,
we filter the accessed memory areas for each file and check if areas were
written before reading. If so, we can also skip testing those bits, as the
program would overwrite the flips again.

Instrumentation is done via the configured \texttt{instrumenter\_call} in the
config file shown in Listing~\ref{lst:expconfig}. The
\texttt{instrumenter\_call} generates the configured
\texttt{instrumenter\_outfile}. The output file contains the memory accesses
formated in the following manner:

\mbox{\texttt{<hex:position\_in\_file> - str:filename}}.

\subsubsection{Generating and Testing the Flips}

Next, we create a new ELF file for each bit for each of the reported bytes.
Depending on the configured number of parallel checks, chroots are created. The
framework makes sure the number of created ELF files does not require more than
the memory available. If there are more files to test than the available memory
allows, the framework takes multiple runs, as shown in
Figure~\ref{fig:frameworkdesign}. A test run starts configured
\texttt{CR\_exec\_file} which will copy a flipped file from the
\texttt{CR\_flip\_folder} to the original position, then run it and check if the
output matches a defined success state. If the flipped file reaches the success
state, the framework writes the flipped address to the \texttt{CR\_log\_file}
and copies the flipped ELF file to the \texttt{CR\_success\_folder}. The
framework passes the file to replace to the \texttt{CR\_exec\_file} when it
calls it. To keep track of which bitflip is tested the filename for generated
ELF files is structured as follows:

\mbox{\texttt{<original\_filename>\_<address\_in\_file>\_<bit\_number>}}.

\subsection{Tweaks added to the Framework}

As our framework reports all accessed memory areas, we apply some tweaks to
these reported memory areas generated with Pin. The additions help us to either
filter unnecessary flips and also to add memory areas which would be missed by
instrumentation as they are only accessed during the setup phase of the program.

\subsubsection{Filtering Memory Accesses}

As seen in Listing~\ref{lst:pinlogcode} we log accesses separated by reading and
writing. This separation is done to apply a simple filter on the reported memory
areas. It is not practical to test a memory area which is written before being
read, as the program will overwrite the memory area before a bitflip would
influence the execution path. We, therefore, test memory areas which are either
only read or read before write access.

\subsubsection{Testing flips in the ELF structure}

As described in Section~\ref{sec:elf}, the ELF structure contains information
for the linker on where to load different segments of the binary in the virtual
address space. Applying flips in this section could lead to misplaced libraries
or different offsets for segment mappings. A call of a function might result in
executing different code as intended and lead to a different outcome of the
program. Therefore, we also test each bit which is used for representing ELF
structures.

\subsubsection{Instrumenting Binaries running as superuser}
~\label{sec:setuidfix}

Some binaries behave differently when being run by a superuser. For example
\texttt{sudo} is a \texttt{setuid} binary owned by \texttt{root}, therefore the
active user running the binary is \texttt{root}. If Pin is running as a regular
user, it is not allowed to access the memory of a superuser\textquotesingle s
process, it, therefore, cannot instrument \texttt{sudo}. Running Pin as
superuser is possible, but starting \texttt{sudo} as \texttt{root} does not
trigger any authentication checks, as the calling user already got superuser
permissions, therefore a change of the current user is not required.

We use the attach-to-process functionality of Pin to bypass this behaviour. In
that way, we can start \texttt{sudo} as a regular user and run Pin as superuser.
We would start \texttt{sudo} and then attach to the resulting process ID. The
problem here is that getting the process ID takes time and during that time
\texttt{sudo} could already perform accesses which then would be missed by
instrumentation. Therefore, we preload a shared library which keeps the
\texttt{sudo} program in a defined state for some time to give the framework
enough time to look up the ID and instrument all relevant code parts.

\begin{figure}
\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Code of the preloaded library to keep the process
waiting for some milliseconds, which gives enough time for Pin to attach to the
process.},
label=lst:presleeplib]
extern const char *__progname;

__attribute__((constructor)) void init(void)
{
  if(!strcmp(__progname, "instrumented_program"))
  {
    size_t i = 0;
    while(i++ < 600000000);
  }
}
\end{lstlisting}
\end{minipage}
\end{figure}

Listing~\ref{lst:presleeplib} shows the code used to generate such a preloaded
library. We use the counting while-loop instead of a call to the sleep system
call because attaching Pin to a process in sleeping state results in a state
where the process cannot wake up again. We also experienced the same issue with
debugging tools on our Linux-based environment, such as \texttt{gdb}. The number
of increments was chosen to have enough time to search the process ID and attach
to it. The compiler attribute \texttt{constructor} makes sure the program
executes this code on loading the library before any other code. We add the path
to our library to the \texttt{/etc/ld.so.preload} file, which makes sure the
library is preloaded by any executed program. The name of the executable is
checked in Line 5 of Listing~\ref{lst:presleeplib} to only call the while-loop
when the binary is our instrumentation target. Otherwise, all executed programs
would execute the time-consuming while-loop during startup.

\subsection{Comparing our Approach to other Techniques}

Our described approach for finding exploitable bitflips is built on a
fuzzing-like approach. We want to look at other ideas we tried to adapt or use
for the searching and argument on why we stuck with our described framework.

\subsubsection{Symbolic Execution}

\texttt{angr}~\cite{angrpaper} offers many tools and functions for binary
analysis and symbolic execution. For this, it can load a binary, search all
possible states and provides locations in the executable where a state has more
than one possible successor. \texttt{angr} allows searching for inputs and
arguments which would end up in a state defined as successful. This state could
either be defined by an address reached during execution or on the output of the
program. The approach \texttt{angr} seems useful for our task of searching
bitflips to change to a success state. However, \texttt{angr} is very limited
when changing the executed machine code to find new states. It works well for
finding inputs for the program to result in a success state. Testing bitflips
with \texttt{angr} results in a limited application of the tool\textquotesingle
s possibilities, where the binary is loaded, a bitflip is applied, and a single
run is made which is then checked if it ends up in the defined success state.
Changing inputs or arguments will not be tested. \texttt{angr} could be used to
test bitflips, but the time needed would be about \SI{10} to \SI{15} times
larger than our approach, because of the time it takes \texttt{angr} to load and
the program and its libraries.

\subsubsection{Using AFL}

Fuzzers like AFL~\cite{aflweb} tests a program by applying different forms of
input and generate those applying a form of edge coverage to learn from changes
from the control flow. AFL uses instrumentation to document the
program\textquotesingle s control flow and adapt its test cases based on changes
of it. AFL offers source code based instrumentation, which might not be suitable
for testing bitflips in binaries as with that approach, the tested executables
would change. According to their documentation~\cite{aflreadme}, AFL also offers
instrumentation of binary-only application. Here they use the QEMU processor
emulator~\cite{qemuweb} as a userland virtual machine. They state in Section 4
of the documentation~\cite{aflreadme} that in this mode execution is 2-5 times
slower than for the compile-time instrumentation approach.

For testing bitflips, the adaption of test cases can be ignored, as we always
stick to the same environment and external inputs. The AFL techniques to learn
from control flow changes could be adapted but as we do not want to build on
source-based instrumentation because of binary changes the additional execution
time for their binary instrumentation made the AFL adaption not practical.

\subsubsection{Using a Fuzzing-like Approach}

The described instrumentation based fuzzing of AFL can be adapted for
instrumentation based bitflip testing. We used Intel Pin~\cite{pintool} for this
approach, as it is the best performing tool for binary instrumentation. The
implementation would instrument every instruction of the program, fork multiple
times. One time for each bit in the instruction and the addressed memory by the
instruction. After the forks, individual bitflips are applied to the memory of
the new processes, and the new processes continue execution without
instrumentation. The outputs of the new processes are then checked for resulting
in a successful state.

This approach turned out to be practical and performed well enough for simple
programs. However, we ran into problems with applications which had the
\texttt{setuid} property and the solution we described in
Section~\ref{setuidfix} did not work for this time. Looking at the execution
times for simple programs they were just a little lower, about \SI{5}{\percent}
as for running pre-generated binary files. However, the time needed for the
generation would be saved, and the memory footprint would be lower as the
processes memory would be copy-on-write. We decided to not go with this
approach, as we wanted to test all kind of binaries, also \texttt{setuid} ones,
such as \texttt{sudo}.

For our framework, we generated the binaries containing the bitflip still in
DRAM memory, to speed up the procedure of copying and applying a bitflip. This
generation phase of the framework showed to take less than \SI{1}{\percent} of
the whole testing process time. Therefore, running multiple generation phases,
because of the increased memory usage, was accepted as a downside of our chosen
testing approach.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Case Study: Rowhammer-targets in real-world Applications}
\label{sec:results}

In this thesis, we want to apply the framework to larger, real-world
applications, with realistic bitflip targets. As
Gruss~\etal~\cite{flipinthewall} already showed, there are bits in the
\texttt{sudoers} library which, when toggled, allow using \texttt{sudo} without
or with a wrong password to still gain the privileges of a superuser. We show
that our framework can find a larger number of exploitable bitflips. We present
the results of the framework applied to real-world applications, which are
commonly used in Linux-based operating systems. In this section, we present all
the applications we tested, the pre-defined successful outcomes, and the
bitflips leading to the desired behaviour. For the results, we discuss how many
exploitable bitflips were found, in what memory section they were and if in an
instruction, in which part. In the end, we want to give some statistic about the
exploitable bitflips and also point out the ones which were exploitable in
multiple applications.

For testing, we used a \texttt{Debian GNU/Linux 9.5} operating system. The
testing environment inside the \texttt{chroot} had the same system. The CPU used
was a \mbox{\texttt{Intel(R) Core(TM) i7-960}} and a total of
\SI{16}{\giga\byte} DRAM memory was installed.

\section{\texttt{sudo} - Privilege Escalation}

\texttt{sudo} is a tool used for privilege management on Linux-based operating
systems. Users can use it to execute commands as another user, if the
tool\textquotesingle s configuration allows it, also as the superuser
\texttt{root}. For the tool to run the given command as another user, the user
has to provide their password.

We want to find all exploitable flips which would allow a user to run
\texttt{sudo} without knowing the password. This exploit would result in a
privilege escalation as the user can become superuser with a bypass of the
credential check.

For testing we call \texttt{sudo} and provide a wrong password for the
credential check. As command we provide reading a file which is owned by
\texttt{root} and can not be read by the calling user. We define the success
state as the call of \texttt{sudo} must print the content of the file owned by
the superuser. We tested version $1.8.19p1$ of \texttt{sudo}.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Results}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

\begin{table}[!htb]
\centering
\begin{tabular}{c|cccc|c}
ELF File & \texttt{.text}  & \texttt{.rodata} & \texttt{.got.plt} &
\texttt{.plt} & Sum of flips:                             \\ \hline
\texttt{ld-linux-x86-64.so.2} & 1   & 0  & 0  & 0  & 1    \\
\texttt{libpthread.so.0}      & 2   & 0  & 0  & 0  & 2    \\
\texttt{sudo}                 & 6   & 0  & 0  & 0  & 6    \\
\texttt{libnns\_compat.so.2}  & 6   & 0  & 1  & 0  & 7    \\
\texttt{libpam.so.0}          & 64  & 0  & 0  & 0  & 64   \\
\texttt{pam\_unix.so}         & 85  & 0  & 0  & 1  & 86   \\
\texttt{sudoers.so}           & 219 & 35 & 5  & 0  & 259  \\ \hline
Sum of flips:                 & 383 & 35 & 6  & 1  & 425
\end{tabular}
\caption{List of ELF files used by the \texttt{sudo(1.8.19p1)} program and the
number of flips causing privilege escalation listed per section.}
\label{tab:sudores}
\end{table}

We present \SI{425} exploitable bitflips in total. Table~\ref{tab:sudores} shows
the ELF files where the flips were found and also shows how many bitflips were
exploitable in different ELF sections.  Most bitflips were found in the
\texttt{sudoers} library but also bits in the linker
(\texttt{ld-linux-x86-64.so.2}) and the threading library
(\texttt{libpthread.so.0}) were exploitable.

We can see that most exploitable bitflips are in the \texttt{.text} sections of
binaries, which is the section holding the executed machine code. The
\texttt{.plt} section refers to the Procedure Linkage Table, which is used to
resolve mappings between position-independent functions and their absolute
addresses. Close to the same is the \texttt{.got.plt} section, which represents
the global offset table, which resolves mappings for position-independent code
parts.

\begin{table}[!htb]
\centering
\begin{tabular}{c|cc|c}
ELF File & opcode & parameter & Sum of flips: \\ \hline
\texttt{ld-linux-x86-64.so.2} & 0 & 1  & 1    \\
\texttt{libpthread.so.0}      & 0 & 2  & 2    \\
\texttt{sudo}                 & 2 & 4  & 6    \\
\texttt{libnns\_compat.so.2}  & 2 & 5  & 7    \\
\texttt{libpam.so.0}          & 17 & 47   & 64   \\
\texttt{pam\_unix.so}         & 36 & 50   & 86   \\
\texttt{sudoers.so}           & 87 & 172  & 259  \\ \hline
Sum of flips:                 & 144 & 281 & 425
\end{tabular}
\caption{List of bitflips causing privilege escalation in
\texttt{sudo(1.8.19p1)} and what they change in instructions.}
\label{tab:sudoflip}
\end{table}

From the \SI{425} exploitable flips \SI{144} were placed in the opcodes of
instructions and \SI{281} were in parameters. Table~\ref{tab:sudoflip} shows how
the flips are divided in that two section for the different ELF files. It is
shown for all files. That about one-third of the flips are applied in the
opcodes and the other two in the parameters.

\begin{figure}
\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to
\texttt{libnss\_compat.so.2} in order to bypass a user privilege check. The call
to \texttt{strcmp} is exchanged because the offset used for the lookuptable
is flipped.},
label=lst:sudoex]
  351b:  0f 84 90 00 00 00  je     35b1
  3521:  48 89 ee           mov    %rbp,%rsi
- 3524:  e8 47 dc ff ff     callq  1170 <strcmp@plt>
+ 3524:  e8 c7 dc ff ff     callq  11f0 <malloc@plt>
  3529:  85 c0              test   %eax,%eax
  352b:  0f 85 3e ff ff ff  jne    346f
\end{lstlisting}
\end{minipage}
\end{figure}

Listing~\ref{lst:sudoex} shows a diff of the \texttt{libnss\_compat.so.2} ELF
file, where a call to \texttt{strcmp} is replaced with a call to \texttt{malloc}
by a single bitflip, causing the later \texttt{jne} instruction to behave
differently.

Testing the \texttt{sudo} program for exploitable bitflips took about \SI{8}
hours of CPU time. The testing was parallelised and split into 24
\texttt{chroot} environments. Testing all bits in the \texttt{sudo} binary
itself took about two to three times as long in an equal configuration.

\section{\texttt{nginx} - HTTP Basic Authentication Bypass}

\texttt{nginx} is a web server, available on for Linux-based operating
systems.~\cite{nginxweb}. The tool can be used to serve websites, and it can
also be configured to support basic authentication schemes.

We want to find all exploitable bitflips which would allow an attacker to access
websites protected with HTTP basic authentication. Such an exploit would bypass
the credential check of the configured web server, which uses \texttt{htpasswd}
for the basic authentication, as described in Section~\ref{sec:httauth}.

For testing we start \texttt{nginx}, wait for about \SI{100}{\milli\second} for
the server to go into an initialised state. Then we request a website protected
with HTTP basic authentication, providing credentials containing the correct
username but a wrong password. If the response contains the content of the
requested website, we add the flipped bit to the list of exploitable bitflips.
We do not care if the response is malformed. We rate the response as successful
as long as the protected site is leaked by it. We tested version $1.10.4$ of
\texttt{nginx}.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Results}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

For the authentication bypass in \texttt{nginx} we can report that only bitflips
in the program\textquotesingle s binary itself were exploitable. We can show
\SI{298} exploitable bitflips in the executable, where all of them were found in
the \texttt{.text} section of the ELF file.

\begin{figure}
\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff of the disassembly for a bitflip applied to
the \texttt{nginx} binary in order to bypass the credential check. The
\texttt{add} instruction is prefixed with a \texttt{0x40}, which is the Intel
REX prefix used to change addressing modes. This prefix changes the computation
before the jump to \texttt{ngx\_http\_headers\_out} at address
\texttt{0x2f1399}.},
label=lst:nginxex]
  2f1365:  00 00                 add    %al,(%rax)
  2f1367:  00 91 7a 0c 00 00     add    %dl,0xc7a(%rcx)
  2f136d:  00 00                 add    %al,(%rax)
  2f136f:  00 10                 add    %dl,(%rax)
- 2f1371:  00 00                 add    %al,(%rax)
- 2f1373:  00 00                 add    %al,(%rax)
- 2f1375:  00 00                 add    %al,(%rax)
- 2f1377:  00 a1 7a 0c 00 00     add    %ah,0xc7a(%rcx)
- 2f137d:  00 00                 add    %al,(%rax)
- 2f137f:  00 14 00              add    %dl,(%rax,%rax,1)
- 2f1382:  00 00                 add    %al,(%rax)
- 2f1384:  00 00                 add    %al,(%rax)
- 2f1386:  00 00                 add    %al,(%rax)
- 2f1388:  b2 7a                 mov    $0x7a,%dl
- 2f138a:  0c 00                 or     $0x0,%al
- 2f138c:  00 00                 add    %al,(%rax)
- 2f138e:  00 00                 add    %al,(%rax)
- 2f1390:  0d 00 00 00 00        or     $0x0,%eax
+ 2f1371:  40 00 00              add    %al,(%rax)
+ 2f1374:  00 00                 add    %al,(%rax)
+ 2f1376:  00 00                 add    %al,(%rax)
+ 2f1378:  a1 7a 0c 00 00 00 00  movabs 0x1400000000000c7a,%eax
+ 2f137f:  00 14
+ 2f1381:  00 00                 add    %al,(%rax)
+ 2f1383:  00 00                 add    %al,(%rax)
+ 2f1385:  00 00                 add    %al,(%rax)
+ 2f1387:  00 b2 7a 0c 00 00     add    %dh,0xc7a(%rdx)
+ 2f138d:  00 00                 add    %al,(%rax)
+ 2f138f:  00 0d 00 00 00 00     add    %cl,0x0(%rip)  <ngx_http_headers_out>
  2f1395:  00 00                 add    %al,(%rax)
  2f1397:  00 c7                 add    %al,%bh
  2f1399:  7a 0c                 jp     2f13a7  <ngx_http_headers_out>
  2f139b:  00 00                 add    %al,(%rax)
\end{lstlisting}
\end{minipage}
\end{figure}

\SI{65} bitflips changed the opcode of an instruction \SI{231} changed
parameters. \SI{2} bitflips changed the context of the executable memory area
because the instruction length was changed by the flip and therefore the context
was changed. In Listing~\ref{lst:nginxex} we can see how changing the lenght of
the \texttt{add} instruction can result in a different outcome for the
execution.

Testing the \texttt{nginx} ELF files took a total of about \SI{18}{\hour} CPU
time. The timing is that high, because we had to make sure the server is up and
ready to reply to our requests for each test. For testing, we have used eight
parallel testing-\texttt{chroot} instances.

\section{\texttt{sshd} - Secure Shell Server Login Bypass}

\texttt{sshd} is a secure shell server implementation which runs on Linux-based
operating systems. It is used together with the \texttt{ssh} client, which
allows to log in on remote hosts via the \texttt{ssh} protocol. According to the
documentation~\cite{sshman}, not only log in via username and password
credentials is supported, but also public key cryptography can be used for
authentication.

We want to find all exploitable bitflips which would allow an attacker to log
into a remote machine without knowing the correct password of the user. The
\texttt{ssh} server is configured to allow accesses from users using password
authentication.

For testing, we start \texttt{sshd}, wait for \SI{100}{\milli\second} for the
server to start and be ready to accept connections. We then use a \texttt{ssh}
client to execute commands in the testing environment via the secure shell
connection. We defined a success state when the output of the client showed a
successful login. We verified the login by executing \texttt{whoami}, which
returns the name of the logged in user. We tested version $7.4p1$ of the
\texttt{ssh} server.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Results}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

For the used \texttt{ssh} server we can only report working bitflips in the
loaded libraries. Additional, all of the reported flips were found in the
\texttt{.text} section of the ELF files. Table~\ref{tab:sshdres} gives an
overview of the number of flips found per file. We can see, that most bitflips
can be found in the \texttt{libc} of the host system, also the cryptographic
library and the linker are affected for Rowhammer targeting a \texttt{ssh}
login.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & \texttt{.text} \\ \hline
\texttt{libc.so.6}         & $34$ \\
\texttt{libcrypto.so.1.0.2} & $6$ \\
\texttt{ld-linux-x86-64.so.2} & $1$ \\ \hline
Sum of flips:                 & $41$
\end{tabular}
\caption{List of flips inside the \texttt{sshd(7.4p1)} program
causing a authentication bypass, whereas all of them were in the \texttt{.text}
sections of dynamically loaded libraries.}
\label{tab:sshdres}
\end{table}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to the
\texttt{libcrypto.so.1.0.2} binary in order to bypass a credential check. The
move from \texttt{rbx} to \texttt{rdi} is exchanged with a move to
\texttt{r15}, this changes the parameter for \texttt{EVP\_MD\_CTX\_test\_flags},
which is highly likely to result in a different outcome.},
label=lst:sshdex]
   1341c5:      74 ad                  je     134174 <EVP_MD_CTX_cleanup>
   1341c7:      be 04 00 00 00         mov    $0x4,%esi
-  1341cc:      49 89 df               mov    %rbx,%rdi
+  1341cc:      48 89 df               mov    %rbx,%r15
   1341cf:      e8 dc e5 f3 ff         callq  727b0 <EVP_MD_CTX_test_flags@plt>
   1341d4:      85 c0                  test   %eax,%eax
\end{lstlisting}
\end{minipage}
\end{figure}

In Listing~\ref{lst:sshdex}, we show a diff for the \texttt{libcrypto} library
used by \texttt{ssh}. We can see how changing the function parameters
(\texttt{rdi}) for \texttt{EVP\_MD\_CTX\_test\_flags@plt} changes the outcome
of the libary call in a way ssh will think it is working with correct
credentials.

Testing the \texttt{ssh} server took about six hours. The timing here is lower
than for \texttt{nginx} or \texttt{sudo}, as the shell server was faster ready
than \texttt{nginx}, and there were not so many flips to test as in
\texttt{sudo}.

\section{Local Login Bypass on Linux-based Operating Systems}

If attackers have local access to computers and the network, the nethammer
attack~\cite{nethammer} could be used to introduce bitflips to the running
system. An attacker could target the login procedure to gain full access to the
system. On most Linux-based systems local logins are done via the
\texttt{/bin/login} application. This program is called on the default terminal
by the init process, after the bootup of the operating system. The goal is to
find bitflips which would allow logging in without knowing the correct password.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Instrumentation}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

As the \texttt{/bin/login} binary has to be run as root, we use a similar
approach as for \texttt{sudo}. We again make use of the preloaded library from
Listing~\ref{lst:presleeplib}. The instrumentation for \texttt{/bin/login} takes
longer than for the other programs. A reason for this could either be the key
derivation functions used or timeouts build in to prevent brute-forcing the
local login. We start the program and attach to the created process shortly
after, we then try to login with a wrong password and wait for the application
to quit. All accesses during this are logged. To simplify the procedure, we
configure the login to allow just one login try instead of the default five.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Testing}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

\texttt{/bin/login} expects input on a \texttt{TTY}, the Linux terminal
interface, using pipes to redirect the input does not work for testing. To get
around this issue, we use \texttt{passh}~\cite{passhweb}, which is usually used
for automating \texttt{ssh} logins, but it also works for our problem. To find
out if we result in a successful state, we run the login binary as root, send
credentials with a correct username and a wrong password, and check if the
system changed the current user from \texttt{root} to the other user. We tested
the \texttt{/bin/login} binary included in the \texttt{shadow-utils 4.4}.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\subsection{Results}
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

For \texttt{/bin/login}, we can report bitflips in loaded libraries and also the
program\textquotesingle s binary itself. All the found bitflips were in the
\texttt{.text} section of ELF files. As Table~\ref{tab:loginres} shows, there
were $178$ flips ending in a successful bypass of the login service. Most flips
were found in \texttt{pam} libraries, which are a major part of the user
management in Linux-based operating systems.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & \texttt{.text} \\ \hline
\texttt{login}         & $57$ \\
\texttt{pam\_unix.so} & $64$ \\
\texttt{pam\_nologin.so} & $2$ \\
\texttt{pam\_securetty.so} & $5$ \\
\texttt{libpam.so.0} & $50$ \\ \hline
Sum of flips:                 & $178$
\end{tabular}
\caption{List of flips inside the \texttt{login(shadow-utils 4.4)} program
causing a bypass of the local login check.}
\label{tab:loginres}
\end{table}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{lstlisting}[style=diff,
                   caption={Diff for a bitflip applied to the
\texttt{pam\_nologin.so} binary in order to bypass a credential check. The
pop to register $15$ gets exchanged with a pop to register $14$, therefore the
value of \texttt{r15} and \texttt{r14} are not as desired and hence the
execution path of \texttt{/bin/login} changes in a way the login
procedure succeeds.},
label=lst:loginex]
  c37:  41 5d                   pop    %r13
  c39:  41 5e                   pop    %r14
- c3b:  41 5f                   pop    %r15
+ c3b:  41 5e                   pop    %r14
  c3d:  c3                      retq
  c3e:  66 90                   xchg   %ax,%ax
\end{lstlisting}
\end{minipage}
\end{figure}

In Listing~\ref{lst:loginex}, we show a diff for the \texttt{pam\_nologin.so}
file after a bitflip was applied at the address \texttt{0x0c3b}. With
the applied flip, register values get changed as the value which should be
written to register $15$ is placed in register $14$ instead, overwriting the
value placed there before.

Testing \texttt{/bin/login} tool about 35 hours. This is mainly due to the long
response time by the program itself, which is probably a countermeasure against
local brute-forcing. Also, there were by far the most memory accesses reported
by the instrumentation pintool.

\section{Summery of the Results}

In summary, we can show, that all our tested programs can be exploited by
bitflips. We show that Rowhammer can be used for privilege escalation and
security bypasses in common applications used in most Linux-based operating
systems. We can report that most bitflips can be found in the \texttt{.text}
section of ELF files, which contains the executed machine code. Also, we show
that not only binaries on its own are suffering such flaws, but also loaded
libraries introduce exploitable bitflips to programs. The diffs of the
disassembly show, that when flipping code, not only the opcode can be abused but
also parameters in instructions.

\begin{table}[!htb]
\centering
\begin{tabular}{c|c}
ELF File               & Shared flips \\ \hline
\texttt{pam\_unix.so} & $52$ \\
\texttt{libpam.so.0} & $18$ \\ \hline
Sum of flips:                 & $70$
\end{tabular}
\caption{Number of flips which work for a login bypass and a \text{sudo}
privilege escalation.}
\label{tab:loginsudo}
\end{table}

Besides that, we can report that some bitflips cause a bypass in multiple
application. For example most \texttt{pam} related flips can be abused in the
\texttt{login} program and \texttt{sudo} as both check against the same user
management. An attacker, therefore, could introduce a flip in the
\texttt{libpam.so.0} file, log in as the user and gain super-user access if the
user is allowed to use \texttt{sudo}. Table~\ref{tab:loginsudo} show the exact
number of shared bitflips between the two applications. Also, for \texttt{sudo}
and \texttt{sshd}, there was one shared bitflip found, namely one in the
\texttt{ld-linux-x86-64.so.2} file at address \texttt{0xfc6c}.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
