%%%%%% Static Data Flips %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Bitflip Attacks on ELF Files}\label{sec:bitflip}

In this chapter, we will discuss our approach to automate the finding bitflips
in ELF files to gain privilege escalation. This is an approach which
Gruss~\etal~\cite{flipinthewall} already have shown by disassembling binaries
and manually looking for them. We start by describing the impact of a single
bitflip. Then, we look at our work and the framework we created to find bitflips
in binaries to change their behaviour to a pre-defined state. We take a look at
the framework design in general. Then we look at the details on how we find bits
to check, how the definition for searching works, how we test the bitflips and
how results are captured and verified.

\section{Changing the Execution Path with a Single Bitflip}

The task of our thesis was to find a bit in an ELF file which we can flip to
change the behaviour in a way that it benefits us. See the code in
listing~\ref{lst:csimbranch} for example. We want to change the binary in a way
it will print \texttt{success} instead of \texttt{fail}, and all this by just
toggling a single bit. For this, we look at the disassembly of the code in
listing~\ref{lst:disasmsimplebranch}. From this, we first mention that we can
change the \texttt{1} can to a \texttt{0}. Besides that, also the opcode of
\texttt{jnz}, namely \texttt{0x75 (1110101)}, can be changed into a \texttt{jz},
as this is \texttt{0x74 (1110100)}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Simple branching code to show an example for a
single bitflip to change the execution path.},
                   label={lst:csimbranch}]
#include <stdio.h>
int main(void)
{
  int x = 0;
  if(x == 1)
    printf("success.\n");
  else
    printf("fail.\n");
  return 0;
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=nasm,
                   caption={Disassemby of the main function created by the
code in listing~\ref{lst:csimbranch}. Shows machine code at given address
inside the ELF file, starting at \texttt{0x063a}.},
                   label={lst:disasmsimplebranch}]
0x063a  push rbp
0x063b  mov rbp, rsp
0x063e  sub rsp, 0x10
0x0642  mov dword [local_4h], 0
0x0649  cmp dword [local_4h], 1  ; [0x1:4]=0x2464c45
0x064d  jne 0x65d
0x064f  lea rdi, str.success.    ; 0x6f4 ; "success."
0x0656  call sym.imp.puts        ; int puts(const char *s)
0x065b  jmp 0x669
0x065d  lea rdi, str.fail.       ; 0x6fd ; "fail."
0x0664  call sym.imp.puts        ; int puts(const char *s)
0x0669  mov eax, 0
0x066e  leave
0x066f  ret
\end{lstlisting}
\end{minipage}

Looking at just the opcodes we could achieve from changing the single byte
\texttt{jnz}~(\texttt{0x75)}), we get a possible of eight different opcodes,
whereas two of them would result in invalid instructions, the eight
possibilities and the results we get, can be seen in table~\ref{tab:jnzflips}.

\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
Opcode & Hex Value & Describtion                                           &
Output              \\ \hline
JNZ    & 0x75      & Jump short if not zero/not equal                      &
fail.               \\ \hline
JZ     & 0x74      & Jump short if zero/equal                              &
success.            \\ \hline
JNBE   & 0x77      & Jump short if not below or equal/above                &
success.            \\ \hline
JNO    & 0x71      & Jump short if not overflow                            &
fail.               \\ \hline
JNL    & 0x7D      & Jump short if less or equal/not greater               &
success.            \\ \hline
GS     & 0x65      & GS segment override prefix                            &
Illegal instruction \\ \hline
PUSH   & 0x55      & ($50+r$) Push onto the Stack &
Illegal instruction \\ \hline
XOR    & 0x35      & Logical Exclusive OR                                  &
Segmentation fault  \\ \hline
CMC    & 0xF5      & Complement Carry Flag                                 &
Illegal instruction \\ \hline
\end{tabular}
\caption{Possible opcodes resulting from changing a single bit in \texttt{JNZ}
and the output when applied in the assembly showed in
listing~\ref{lst:disasmsimplebranch}.}
\label{tab:jnzflips}
\end{table}

From this, we gain the knowledge that at least three bit flips to the opcode
give us our desired behaviour. Additionally we can add the bitflip to the $1$,
which makes it four. From this point, the question arises how do we automate
this searching process?

\section{Automating the Finding of Feasible Bitflips}

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
