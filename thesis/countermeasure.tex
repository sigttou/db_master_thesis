%%%%%% Countermeasures %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Countermeasures}\label{sec:countermeasure}

In this chapter, we discuss countermeasures. First, we look at countermeasures
against Rowhammer and microarchitectural attacks in general. Then we look at
measures that make our testing less practical, and make our results less useful
for an attacker. Finally, we discuss measures which, when applied to computer
systems, make them more secure.

\section{Microarchitectural Attacks}

Fixes for microarchitectural attacks can be applied to different layers of a
system. The KAISER patch for kernel page-table isolation by
Gruss~\etal~\cite{kaiserpaper} is applied to the kernel to prevent leakage of
kernel memory by Meltdown~\cite{meltdown}. For other attacks, such as Spectre,
Kocher~\etal~\cite{spectre} state that lower layers, like the
CPU\textquotesingle s microcode, have to be fixed. Kocher~\etal~\cite{spectre}
also state that a long-term solution to prevent microarchitectural attacks is a
fundamental change of instruction set architectures.

\subsection{Rowhammer}

Besides fixing systems to prevent microarchitectural attacks, it is also
possible to prevent the exploitation of microarchitectural flaws by checking
programs for malicious behaviour. Irazoqui~\etal~\cite{mascat} present a
Micro-Architectural Side Channel Attack Trapper (MASCAT), which uses static
analysis of binaries to detect microarchitectural attacks.
Irazoqui~\etal~\cite{mascat} state characteristics of attacks and what code
parts indicate a microarchitectural attack. To detect a possible use of
Rowhammer, MASCAT checks for cache evictions in binaries.
Irazoqui~\etal~\cite{mascat} show that using \texttt{clflush} in a loop is
likely part of a Rowhammer attack. Also, \texttt{monvnti} and \texttt{movntdq}
are listed as suspicious, as these instructions allow direct access to the DRAM
and bypassing the cache. Besides looking for these instructions,
Irazoqui~\etal~\cite{mascat} also state, that a program using self-map
translation to resolve the mapping between physical and virtual memory is likely
to be a threat to the system as knowledge about this mapping is part of
Rowhammer attacks.

Besides statically checking binaries, checking the behaviour of a program also
can detect an ongoing attack. Aweke~\etal~\cite{anvil} present a software-based
solution to detect ongoing Rowhammer attacks, namely ANVIL. ANVIL uses hardware
performance monitoring to monitor DRAM row accesses. If a row is accessed
repeatedly, ANVIL forces refreshing of neighbouring rows.
Aweke~\etal~\cite{anvil} implemented ANVIL as a kernel module for Linux and
state that their detection and prevention system leads to an average slowdown of
\SI{1}{\percent} and a worst-case slowdown of \SI{3.2}{\percent} of the system.

Brasser~\etal~\cite{canttouch} show another software mitigation against
Rowhammer attacks. Their countermeasure prevents an attacker to corrupt kernel
memory from user mode. Brasser~\etal~\cite{canttouch} extend the physical memory
allocator of the Linux kernel to isolate the memory of the kernel and the
userspace on DRAM storage. The mitigation by Brasser~\etal~\cite{canttouch},
CATT, does not prevent bitflips from happening but removes the possibility to
exploit bitflips in kernel memory. CATT splits the memory layout into security
domains and makes sure that memory from different domains is not placed in
neighbouring rows on the DRAM chip. This placing prevents an attacker from using
kernel memory as a target for Rowhammer.

Gruss~\etal~\cite{flipinthewall} show that it is still possible to mount
privilege-escalation attacks with such countermeasures present. For the approach
by Brasser~\etal~\cite{canttouch}, they show that the isolation from kernel
memory does not prevent privilege escalation as they introduce bitflips to ELF
files, which then allow an attacker to gain superuser privileges. For defeating
static analysis and performance counter based mitigations,
Gruss~\etal~\cite{flipinthewall} present attacks based on the SGX enclave.
Gruss~\etal~\cite{flipinthewall} state that this defeats performance counter
monitoring countermeasures as executions inside the enclaves are not monitored
by the CPU\textquotesingle s performance counters.

To prevent exploiting ELF files with bitflips introduces to the storage devices
operating systems can store a hash of the executables and check the checksums
before execution. Bitflips attacks on storage devices are described by
Kurmus~\etal~\cite{rowssdhammer}. Cai~\etal~\cite{rownandhammer} show how MLC
NAND flash memory devices can be targeted to introduce exploitable memory
corruptions to solid-state drives. Checking the hash of the executable before
execution would detect such a change of the ELF file and can prevent the
execution of an exploiting binary.

\section{Making Bitflip Testing Less Practical}

From looking at our binary analysis and the impact we get from knowing that
operating system ship the same ELF files to all their users, we can conclude
that having different ELF files per instance would drastically lower our impact.
Doing so would mean, an attacker would need to analyse bitflips per target.
Whereas this would be a valid countermeasure, it is not practical. Also, having
different ELF files per system breaks other security improvements. Compiler
developers and developers of wide-spread software currently push the technique
of reproducible builds. Whereas the Debian-close organisation
reproducible-builds~\cite{reprobuilds} is one of the most significant
contributors in this field. The advantage of reproducible builds is that all
binaries compiled with the same compiler, same configuration and same
source code will not differ, this makes detection of changes very easy. The
technology allows a bit-by-bit compared verification of the full build chain
used for the program. By this, also changes or backdoors introduced by a
malformed compiler or linker could be detected.

Reproducible builds could also help to define other countermeasures to bit flips
in the binary memory. Whereas the operating system can verify ELF files by using
stored checksums, it would also be possible to use similar techniques to do this
with in-memory code or data at runtime. As Suh~\etal~\cite{memintegrity} have
shown in their work about memory integrity verification and encryption for
secure processors. Other work that could be looked at as countermeasure is
DRIVE~\cite{drive} by Rein~\etal or SPEE~\cite{spee} by Gelbart~\etal. Those apply
code verification to binaries before execution and during runtime.

The encryption of binaries could in general seen as a countermeasure to
bitflips. If decryption happens on each access to the file stored in memory. If
the entire file is stored decrypted it would not improve security. If a bit is
flipped inside an encrypted ELF file, decryption is likely to fail, meaning the
binary could not continue execution and the program would crash in case of an
applied bitflip.

\section{Improving General System Security}

There is no unbreakable, unhackable, totally secure system. Users and vendors
need to be aware of this. If vulnerabilities are found vendors should react to
provide possibilities for their users to be secure. Like provide patches for
either their microcode, operating system kernels or programs itself. Users
should be informed about security updates and apply them to their environment
as soon as possible. For updates to be in place on time, it is vital for
vendors to work closely with operating system developers, to push patches very
soon after or even before public disclosure.

As systems should generally be seen as unsafe and programs running cannot be
trusted, a defensive approach for operating system development might be a right
approach. Defensive coding is usually based on a multiple wall approach. This
allows having defensive structures in place even if some defences are broken.
Whereas developers should find motivation in writing secure code, mistakes
happen, and old software is sometimes run. Bugs like buffer-overflow often lead
to code execution. Operating systems introduced techniques like address space
layout randomisation (ASLR), to make attacks abusing buffer-overflow harder as
an attacker would not know positions of injected code anymore. From this other
attack were designed, using return-oriented programming (ROP) and using known
positions inside shared libraries to craft code from code-pieces inside those.
In their work Ruan~\etal~\cite{ropsur}, show a survey of ROP defence mechanisms.
They point out the effectiveness of randomisation in memory, which would also
increase the defence for Rowhammer. Additional there are approaches described
using instrumentation to detect ROP attacks, which could again also be used to
detect the usage of Rowhammer.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
