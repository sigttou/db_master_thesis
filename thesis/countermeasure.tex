%%%%%% Countermeasures %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Countermeasures}\label{sec:countermeasure}

In this chapter, we want to look at countermeasures. At first, we look at
measures against rowhammer and microarchitectural attacks in general. Then we
want to look at measures which would reduce the impact of our work. In the end,
we want to close with measures which could be applied to computer systems, in
general, to make them more secure.

\section{Microarchitectural Attacks}

For this kind of bugs, it is vital to check who is to blame for it, to know who
needs to define the countermeasure. For attacks like
Foreshadow~\cite{foreshadow}, Meltdown~\cite{meltdown} and
Spectre~\cite{spectre} it is clear that that bug is caused by the CPUs
manufactured by Intel and AMD. Even if there are countermeasures like
Kaiser~\cite{kaiserpaper}, which would prevent leakage of kernel memory by
Meltdown, the bug remains in the microcode, and other processes\textquotesingle
memory can still be leaked. Vendors need to address such problems directly, by
either deprecating CPUs or patch the bugs with microcode updates.
Countermeasures applied to other layers might not be as effective and bring a
performance drop with them.

\subsection{Cache Attacks}

Cache attacks are mostly timing-attacks, where based on the content of the
cache, accesses to memory take less time. Vendors cannot, and should not, fix
this, as the attack is based on the principle of how caches work. Cache-timing
attacks often try to gain information on other processes, by loading the same
library and check what parts are accessed. Gruss~\etal~\cite{gruss2015cache}
showed how such an attack could be used to build a keylogger, as memory accesses
differ for different keys. They also show how to generate cache-attacks
automatically without an in-depth knowledge of the targeted program and system.
They also state that a possible removing of the \texttt{clflush} instruction is
not a sufficient countermeasure, as there are ways to build cache-attacks with
Evict+Reload. They propose disabling shared-memory as a countermeasure, but
operating-systems use this technology a lot to have lower memory-footprints.
They propose a solution where security relevant functions can be marked as not
shared, to remain the low memory-footprint but protect functions which could
leak sensitive information. It would be down to developers of libraries and
programs to mark these functions then. Overall there might be no perfect
countermeasure to cache-attacks, but there are ways to lower their impact on
security.

\subsection{Rowhammer}

Rowhammer is an issue which occurs because of the missing quality checks by
vendors, the leakage of bit-charges to change other memory areas is a hardware
fault and needs fixing on this layer. Also, users of current DRAM chips need to
be protected, and their risk of using their hardware should be minimalised. In
their work about rowhammer, Gruss~\etal~\cite{flipinthewall} analyse various
countermeasures. Tools like the Micro-Architectural Side Channel Attack Trapper
(MASCAT) by Irazoqui~\etal~\cite{mascat} could be used by anti-virus software to
prevent users from executing software making use of cache-attacks. With a
physical memory separation of kernel memory and user memory, privilege
escalation by applying bitflips to page-tables can be prevented.

Brasser~\etal~\cite{canttouch} showed how such a separation could be built
inside an OS, by changing the code for the physical memory allocator. Another
way to prevent rowhammer would be to detect an ongoing attack during the runtime
of a program. With their work about ANVIL, Aweke~\etal~\cite{anvil} showed such
a detection technique. They track DRAM accesses using hardware performance
measures and check for frequently accessed row to detect the so-called
aggressors. As prevention, they refresh nearby rows to make them secure against
possible flipping. Their benchmarking shows that they have less than one per
cent false-positives and an average performance drop of about one per cent.

Operating system vendors could implement another countermeasure for the file
cache. Our work relies on the file cache to be used when we execute the ELF
file. Operating systems could either recheck file contents before execution, as
in recheck some checksum, or force loading binaries from the disk instead of
using the cache. In such cases, the performance drop would be rather small.

\section{Reducing the Impact of Bit-Flip Testing}

From looking at our binary analysis and the impact, we get from knowing that
operating system ship the same ELF files to all their users, we can conclude
that having different ELF files per instance would drastically lower our impact.
Doing so would mean, an attacker would need to analyse bitflips per target.
Whereas this would be a valid countermeasure, it is not practical. Also, having
different ELF files per system breaks other security properties. Compiler
developers and developers of wide-spread software currently push the technique
of reproducible builds. Whereas the Debian close organisation
reproducible-builds~\cite{reprobuilds} is one of the most significant
contributors to this field. The advantage of reproducible builds is that all
binaries compiled with the same compiler, same configuration and same
source-code will not differ, this makes detection of changes very easy. The
technology allows a bit-by-bit compared verification of the full build chain
used for the program. So, also changes or backdoors introduces by a malformed
compiler or linker could be detected.

Reproducible builds could also help to define other countermeasures to bit flips
in the binary memory. Whereas the operating system can verify ELF files by using
stored checksums, it would also be possible to use similar techniques to do this
with in-memory code or data at runtime. As Suh~\etal~\cite{memintegrity} have
shown in their work about memory integrity verification and encryption for
secure processors. Other work that could be looked at as countermeasure is
DRIVE~\cite{drive} by Rein or SPEE~\cite{spee} by Gelbart~\etal. Those apply
code verification to binaries before execution and during runtime.

The encryption of binaries could in general seen as a countermeasure to this if
encryption happens on each access to the file content based in DRAM if the whole
file is stored decrypted it would not improve security. If a bit is flipped
inside an encrypted ELF file, decryption is likely to fail, meaning the binary
could not continue execution and the program would crash in case of an applied
bitflip.

\section{Improving General System Security}

There is no unbreakable, unhackable, totally secure system. Users and vendors
need to be aware of this. If vulnerabilities are found vendors should react to
provide possibilities for their users to be secure like patched for either their
microcode, operating system kernels or programs itself. Users should be informed
about updates and apply them to their environment. For updates to be in place on
time, it is vital for vendors to work closely with operating system developers,
to push patches very soon after or even before a bug-release or public
disclosure.

As systems should generally be seen as unsafe and programs running cannot be
trusted, a defensive approach for operating system development might be a right
approach. Defensive coding is usually based on a multiple wall approach. This
allows having defensive structures in place even if some defences get broken.
Whereas developers should find motivation in writing secure code, mistakes
happen, and old software is sometimes needed to run. Bugs like buffer-overflow
often lead to code execution. Operating systems introduced techniques like
address space layout randomisation (ASLR), to make attacks abusing
buffer-overflow harder as an attacker would not know positions of injected code
anymore. From this other attack were designed, using return-oriented programming
(ROP) and using known positions inside shared libraries to craft code from
code-pieces inside those. In their work Ruan~\etal~\cite{ropsur}, show a survey
of ROP defence mechanisms. They point out the effectiveness of randomisation in
memory, which would also increase the defence for rowhammer. Additional there
are approaches described using instrumentation to detect ROP attacks, which
could again also be used to detect the usage of rowhammer.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
