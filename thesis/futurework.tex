%%%%%% Future Work %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Future Work}\label{sec:futurework}

In this chapter we want to present an outlook for attacks in the field of
microarchitectural attacks, we want to look at these attacks in general first
and then derive possible future outcomes from current trends. We also want to
look at the combination of these attacks with testing techniques used in other
areas. Also, we also want to look at attacks in cryptography which rowhammer
could reintroduce. In the end, we want to find some possibilities for how future
projects or research could use our work.

\section{Microarchitectural Attacks}

Based on the current releases in the area of rowhammer and microarchitectural
attacks, in general, it will get more interesting to automate attacks on this
layer to make it possible to target multiple programs and systems without
in-depth knowledge about the target. With automated attacks and vulnerability
search not only the number of attacks rises but also security measures, as
techniques like fuzzing allow testing without knowing too much about the code,
developers can have their code tested and improve stability.

In general, we can see a more connecting work between microarchitectural attacks
and classic exploitation techniques. With improved attacks also awareness of
vulnerabilities such as cache attacks or other side-channels is improved as more
users are affected. Latest attacks such as Meltdown~\cite{meltdown} and
Spectre~\cite{spectre} by Lipp and Gruss~\etal have shown this already. Another
example of a famous microarchitectural attack Foreshadow~\cite{foreshadow},
released in August 2018 by Bulck~\etal. The three attacks are related as they
target the CPU internal code used to execute machine code given to it.

\paragraph{Meltdown} is an attack presented by Lipp~\etal~\cite{meltdown}. The
attack targets the memory isolation between the operating system's kernel and
the userland memory and shows how the CPU's out-of-order execution can lead to a
leak of information from kernel memory to a user program. Meltdown makes use of
a side-effect of this execution method. The CPU wants to use as many computing
units as possible. It will execute code as soon as all dependencies are
resolved. So inside a program computing could happen ahead of other code parts.
In a simplified view, the attacker accesses kernel memory, which the CPU reads
out-of-order, the CPU executes other code and receives an exception because of
the disallowed memory access, which already happened before. This execution
order still makes accesses to caches and DRAM as it would normally access the
memory. Therefore the cache could be used to transmit the information. Meltdown
makes use of the Flush+Reload cache attack, as they use the read kernel memory
to flush certain cache lines. Access times to memory then tells which cache
lines the program cleaned. Hence it leaks the kernel memory content. Lipp~\etal
propose the KAISER countermeasure as a fix for this vulnerability. This work by
Gruss~\etal~\cite{kaiserpaper} is used to separate kernel and user memory
addresses. Their proof-of-concept implements a complete separation of the two
memory spaces inside the Linux kernel, which makes sure no information about the
kernel execution is leaked to the userspace.

\paragraph{Spectre} is an attack presented by Kocher~\etal~\cite{spectre}. It
also targets information leakage by features modern CPUs provide. The attack
gained its name form exploiting speculative execution which makes use of the
branch-prediction unit inside the CPU. The CPU executes code which maybe needs
execution, later on, the CPU executes multiple branches and results are either
thrown away or reported to the program later on. Spectre uses this behaviour to
leak information to an attacker by using side-channels inside the predicted
code. The attack breaks multiple security measures which would usually be in
place in modern operating systems. In their work, the researchers show multiple
variants of exploiting the different behaviours caused by speculative execution.
For example see the code in Listing~\ref{lst:spectre1}, as shown in their work.
The speculative execution executes the array access before the if condition
check. The \texttt{array1[x]} can point to kernel memory, for example, returning
some secret, then the \texttt{array2} is accessed at a page which refers to the
secret. This can later be checked again using cache accesses timings using
Prime+Probe or Flush+Reload again. The attacker can see the outcome of the
accesses after the condition check, even if it fails, as it was executed
speculatively. Other variants make use of similar behaviours of the CPU. The
researchers also show how the Spectre attack can be applied using JavaScript.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Code for Spectre variant one, showing a
conditional branch example, as seen by the work done by
Kocher~\etal~\cite{spectre}.},
                   label={lst:spectre1}]
if(x < array1_size)
  y = array2[array1[x] * 4096];
\end{lstlisting}
\end{minipage}

\paragraph{Foreshadow} is an attack by van Bulck~\etal~\cite{foreshadow}.  The
attack targets the Guard eXtension (SGX) in current Intel CPUs. The researchers
use already known speculative execution bugs to gain knowledge of secret memory
used inside the SGX environment which is transferred to the CPU's cache. The
attack works similar to the Meltdown attack, but it is more challenging because
of the SGX and its additional memory protection layers. With this attack, the
security promises on the hardware layer made by Intel are broken.
Countermeasures against this attack cannot be applied to the kernel layer. Intel
needs to patch their microcode in order to prevent the Foreshadow attack.

Attacks like these show a real-world threat and need to be patched on a
low-system level. Vendors need to publish fixes for the microcode. Operating
systems then need to push these fixes to its users and update the CPU's internal
code. Operating System vendors fixed other bugs, like Meltdown and Spectre by
kernel code changes, which caused a performance drop for the users.

With more attacks in this field targeting end-users, cloud environments, servers
and mobile devices. We can see the number of published work rising in the near
future. Automated exploit technologies will, therefore, influence
microarchitecture attacks even more. We can see researchers pushing more on
fuzzying on hardware-level and microcode-level. As knowledge on about how CPUs
work rises, we predict an increasing number of similar attacks on various other
architectures.

While CPU vendors need to improve their architecture and fix parts of their
CPU's microcode, researchers and developers will try to avoid bugs and CPU based
exploits by pushing open architectures and open implementations more. The most
popular Free Software instruction set architecture is RISC-V. It is built on the
principles of reduced instruction set computing (RISC). RISC-V started in 2010,
and lots of researchers have contributed since then. There are implementations
in place, which implement System-on-Chip designs of RISC-V, such as
lowRISC~\cite{lowrisc}. Other research areas use RISC-V  to implement CPU
designs to improve systems, by adding security or optimising options. Such as
Ming~\etal~\cite{smarts} showed in their work of introducing a memory protection
unit (MPU) in a RISC-V SOC. The MPU is used to encrypt and verify memory in
DRAM, where they use a Rocket core with tagged memory based on a lowRISC
implementation. Tagged memory is a technology where bedsides pointers to memory
also information is stored about the referenced memory. For example, in a 64bit
system, one could use 48 bits for addressing memory and use the other 16 bits to
store information, like access rights, encryption information or a checksum of
the referenced memory area. With increasing attacks on memory safety such as
rowhammer, we can see an increase in such countermeasures like tagged memory.

As machine learning is another fast-growing field in computer science, we can
see that testing and exploitation can learn more and more from already found
bugs. This data can be used to find errors in new code. There also exist bug
prediction models, like Puranik~\etal~\cite{bugprediction} showed in their work.
These models can be applied to code and predict if there is a bug. We can see
that these prediction models will influence microarchitectural attacks, as the
behaviour of the CPU in certain states could be analysed and conclusions about
faulty behaviour could be drawn.

With the increasing complexity of CPUs and their design including more
dependency on microcode, we see an increasing number of bugs coming from this
area. Finding bugs by automation is already a topic in security research, for
microarchitectural attacks we can see this trend continuing.
Domas~\cite{sandsifter} already showed how fuzzying is applied to the x86 ISA in
his work, named \texttt{sandsifter}. The tool is open-source and published on
GitHub~\cite{sandsifterurl}. \texttt{sandsifter} is written in Python, and the
developer built it to audit x86 CPUs. It can be used to find hidden instructions
or hardware bugs. The tool generates machine code, executes it and checks the
behaviour of the CPU during execution. The tool already succeeded in finding
undocumented opcodes, bugs in disassembles and hypervisors which also were
security related. The results and whitepaper were released at the Blackhat
conference in 2017~\cite{sandsifter}. With such a tool already in place, we can
see adaptions of it for other architectures in the near future. Also besides
only fuzzying instructions, we can also see similar tools being introduced for
memory accesses to fuzz cache behaviour for example.

\section{Possible Attacks against Cryptography using Rowhammer}

We showed how nonce misusage could be introduced by single bitflips to target
AES-GCM implementations. Attackers could use this idea to target other
cryptographic implementations too. Especially those using a counter nonce. Also,
from our work and research inside the OpenSSL source code, we can see other
memory areas to be attacked, such as session reuse by flipping bits, or changing
used cyphers if identifiers are enumerated. Such attacks could not only break
encryption or allow key-recovery but also allow to break authenticity and
confidentiality when an attacker flips bits in tags inside message
authentication codes.

Dobraunig~\etal~\cite{noncestat} showed statistical attacks against nonce-based
authenticated encryption schemes. They show fault attacks on various modes of
AES, such as GCM, CCM, EAX or OCB. They show how faults would affect the
algorithm when they are introduced before the MixColumn step of AES. Work on
faults in memory, like rowhammer, could be used as a fault source here and work
like this could be used to show future attacks using single bitflips. We can see
more upcoming work in that regard in the future of fault attack research.

We already saw a combination between microarchitectural attacks and
cryptographic attacks. Such as Yarom~\etal~\cite{noncerec} showed, that it is
possible to use FLUSH+RELOAD cache attacks to recover ECDSA nonces in OpenSSL.
They show an attack which allows a partial key-recovery in they Elliptic Curve
Algorithm implementation with only observing a single signing process. With a
key recovery on this level, it allows forgery for future data transmissions.

\section{Improving and Reusing our Testing-Framework}

For attacks based on memory accesses, we can take away that tools such as
Pin~\cite{pintool} or angr~\cite{angrpaper} will be a significant factor for
analysis. The work of Chabbi~\etal\cite{pincallpaths} could also be taken to
improve our attack as they provide an even more in-depth view of execution paths
in binaries. Using such detailed graphs, more bytes to test could be filtered,
speeding up our framework even more.

On the other side, we can see our framework working as a base implementation for
other test environments for parallel testing use cases. The environment it very
adaptable and developers can exchange single components without much effort.
Testing inside \texttt{chroot} could be changed to container environments like
Docker~\cite{docker}, to provide more safety or better abstraction of the host
operating system. Also, virtual machines could be used, if the software has to
be tested on other kernels or operating systems. The testing scripts could also
be replaced to work with multiple input files for a program instead of different
binaries. This would make it possible to use the framework as a basis for a
fuzzer. Even a combination with fuzzers would be possible, as the framework
could be combined with \texttt{afl}~\cite{aflweb} to provide a parallel fuzzing
framework, which would either allow fuzzing in multiple environments or as a
general way to parallelise \texttt{afl}.

Also for the part where binaries are instrumented with Intel Pin at the moment,
replacements or other sources for analysis could be used. Like the
QBDI~\cite{qbdi} tool for dynamic instrumentation could be used instead, which
provides a wider range for software architectures, such as ARM or AArch64.
Additional a complete open source solution for instrumentation is available in
DynamoRIO~\cite{dynrio}, which could replace Pin.

As other use cases for our framework, we could also see it being used as a basis
for malware research, to track the behaviour of malware in different
environments, as it allows setting up many different systems in a short time and
tracks events inside those systems.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
