%%%%%% Dynamic Data Attack %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{
\chapter{Bitflip Attacks on Dynamic Data}\label{sec:automate}

In this chapter, we want to take a look at data created at the runtime of the
program and how flips to that could benefit an attacker. We will go into details
about OpenSSL and how bitflips can make attacks like a nonce-misuse possible. We
want to apply a similar attack as Böck~\etal describe in their work about
\textquotedbl practical nonce misusage
attacks\textquotedbl\cite{gcmnonceattack}. By this, we want to show how
Rowhammer can reintroduce previous attacks.

\section{Analysis of OpenSSL for possible Nonce Misuse Flips}

We look at the implementation of AES-GCM inside OpenSSL. We see the general
AES-GCM context struct in listing~\ref{lst:aesstruct}. Additional to that we
take a look at the cypher context struct in listing~\ref{lst:ciphctx}. The
interesting connection between those two is the initialisation vector
\texttt{iv} which is updated on each call to the GCM function. The
\texttt{GCM128\_CONTEXT} provides the hashing and multiplying function in the
Galois field.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Struct used by OpenSSL to describe the AES-GCM
context. The IV used is stored in the memory pointed to by \texttt{iv}. Source
is taken from OpenSSL version $1.1.0g$},
                   label={lst:aesstruct}]
typedef struct {
  union {
    double align;
    AES_KEY ks;
  } ks;                       /* AES key schedule to use */
  int key_set;                /* Set if key initialised */
  int iv_set;                 /* Set if an iv is set */
  GCM128_CONTEXT gcm;
  unsigned char *iv;          /* Temporary IV store */
  int ivlen;                  /* IV length */
  int taglen;
  int iv_gen;                 /* It is OK to generate IVs */
  int tls_aad_len;            /* TLS AAD length */
  ctr128_f ctr;
} EVP_AES_GCM_CTX;
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={Context struct describing the Cipher used in TLS.
This struct is used as the SSL context inside OpenSSL. Source is taken from
OpenSSL version $1.1.0g$},
                   label={lst:ciphctx}]
struct evp_cipher_ctx_st {
  const EVP_CIPHER *cipher;
  ENGINE *engine;     /* functional reference if
                       * 'cipher' is ENGINE-provided */
  int encrypt;        /* encrypt or decrypt */
  int buf_len;        /* number we have left */
  unsigned char oiv[EVP_MAX_IV_LENGTH]; /* original iv */
  unsigned char iv[EVP_MAX_IV_LENGTH]; /* working iv */
  unsigned char buf[EVP_MAX_BLOCK_LENGTH]; /* saved partial
                                            * block */
  int num;           /* used by cfb/ofb/ctr mode */
  /* FIXME: Should this even exist? It appears unused */
  void *app_data;    /* application stuff */
  int key_len;       /* May change for variable length cipher */
  unsigned long flags; /* Various flags */
  void *cipher_data; /* per EVP data */
  int final_used;
  int block_mask;
  unsigned char final[EVP_MAX_BLOCK_LENGTH]; /* possible final
                                              * block */
} /* EVP_CIPHER_CTX */ ;
\end{lstlisting}
\end{minipage}

For the attack to work, we would need the IV to be reused, just as described by
Böck~\etal\cite{gcmnonceattack}. As OpenSSL uses a counter IV for AES-GCM
instead of a random value, flipping back a lower bit would probably cause a
decrement of the counter which makes reuse very likely. As the described attack
states, this would cause a break of the cryptography for future messages and the
attacker could even craft valid ciphertexts and overtake sessions. For the
attack with Rowhammer, we would target the \texttt{iv} array in the
\texttt{EVP\_CIPHER\_CTX} struct, as seen in the listing~\ref{lst:ciphctx}.

\subsection{Likelihood of a Nonce-Misuse introduced by Rowhammer}

In their work, nethammer, Lipp~\etal\cite{nethammer}, stated how it is possible
to send network requests which cause memory accesses in a manner that they
introduce Rowhammer faults. With this knowledge and the possibility of
nonce-misuse attacks in OpenSSL by bitflips, an attacker could overtake TLS
sessions with only remote access to the network.

Looking at the OpenSSL source code, we can see that for each TLS connection at
least those two context structs are generated. There is one general SSL struct
needed, one AES-GCM context struct and two cypher contexts, as one is used for
sending and one for receiving. The working IVs make 32 bytes of this memory. The
sum of the structs for one TLS connection is 1960 bytes. If we could fill the
DRAM with just these structs, a Rowhammer flip hitting an IV happens with a
probability of about 1.5 per cent. The attack is therefore already quite
unlikely, as also, only lower bits are allowed to be hit, to make a nonce
counter reuse likely. Also, we cannot just hold these structs in memory, and the
operating system usually limits the number of parallel TLS connections.

\subsection{Practical Analysis of Nonce-Reuse caused by Rowhammer}

We set up two versions for the practical analysis of the nonce misusage, where
one uses multiple processes, and one uses multithreading. In both cases, we
implemented a simple endless sending loop which will keep the TLS connection to
any client open and sent some string every second. Listing~\ref{lst:ssltestcode}
shows the code parts used in both cases. The code makes sure the connection will
send the reply every second, as long as the client accepts the write.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=CStyle,
                   caption={},
                   label={lst:ssltestcode}]
if (SSL_accept(ssl) <= 0) {
    ERR_print_errors_fp(stderr);
}
else {
  int run = 1;
  while(run)
  {
    if(SSL_write(ssl, reply, strlen(reply)) < 0)
      run = 0;
    sleep(1);
  }
}
SSL_free(ssl);
close(client);
\end{lstlisting}
\end{minipage}

We force the server to use AES-GCM by using the \texttt{netcat} tool with the
parameter \texttt{--ssl-ciphers ECDHE-RSA-AES256-GCM-SHA384} as client.

For our experiments, we had a memory increase of about 5440 bytes for each
forked process. With threading, the increase was slightly less. We never
achieved filling a major part of the memory with TLS structs so that we came
near the 1.5 per cent, the probability in practical implementations is therefore
even lower. If it is possible to get a thousand parallel connections, with 5440
bytes each, with 32 bytes in initialisation vectors, it will result in 5.19
megabytes of memory representing TLS connections, with 0.59 percent of this
being IVs. In a server setup with four gigabytes of DRAM, the IVs would only
make $74.5\cdot10^{-6}$ per cent. Even if an attacker could gain knowledge
about the four-kilobyte pages used to store TLS structs, it would be tough to
hit IVs with Rowhammer. Given this knowledge, we can conclude that a remote
attack with nethammer is very unlikely to succeed in nonce misusage.
%}}}

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End:
